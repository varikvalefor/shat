\documentclass{report}

\usepackage{ar}
\usepackage[bw]{agda}
\usepackage{ifsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{mathabx}
\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage{newunicodechar}

\newunicodechar{‚à∑}{\ensuremath{\mathnormal\Colon}}
\newunicodechar{ùîΩ}{\ensuremath{\mathnormal{\mathbb F}}}
\newunicodechar{ùïÉ}{\ensuremath{\mathnormal{\mathbb L}}}
\newunicodechar{‚Ñï}{\ensuremath{\mathnormal{\mathbb N}}}
\newunicodechar{ùïä}{\ensuremath{\mathnormal{\mathbb S}}}
\newunicodechar{‚Ñ§}{\ensuremath{\mathnormal{\mathbb Z}}}
\newunicodechar{‚Ñö}{\ensuremath{\mathnormal{\mathbb Q}}}
\newunicodechar{‚àò}{\ensuremath{\mathnormal\circ}}
\newunicodechar{‚àÄ}{\ensuremath{\mathnormal\forall}}
\newunicodechar{‚ä§}{\ensuremath{\mathnormal\top}}
\newunicodechar{Œª}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{‚Üí}{\ensuremath{\mathnormal\rightarrow}}
\newunicodechar{‚àÉ}{\ensuremath{\mathnormal\exists}}
\newunicodechar{‚àà}{\ensuremath{\mathnormal\in}}
\newunicodechar{‚àâ}{\ensuremath{\mathnormal\notin}}
\newunicodechar{‚¶É}{\ensuremath{\mathnormal{\lbrace\hspace{-0.3em}|}}}
\newunicodechar{‚¶Ñ}{\ensuremath{\mathnormal{|\hspace{-0.3em}\rbrace}}}
\newunicodechar{·µ¢}{\ensuremath{\mathnormal{_\AgdaFontStyle{i}}}}
\newunicodechar{‚Çó}{\ensuremath{\mathnormal{_\AgdaFontStyle{l}}}}
\newunicodechar{‚Çõ}{\ensuremath{\mathnormal{_\AgdaFontStyle{s}}}}
\newunicodechar{·µ•}{\ensuremath{\mathnormal{_\AgdaFontStyle{v}}}}
\newunicodechar{‚Çí}{\ensuremath{\mathnormal{_\AgdaFontStyle{o}}}}
\newunicodechar{·µá}{\ensuremath{\mathnormal{^\AgdaFontStyle{b}}}}
\newunicodechar{ ≥}{\ensuremath{\mathnormal{^\AgdaFontStyle{r}}}}
\newunicodechar{·µò}{\ensuremath{\mathnormal{^\AgdaFontStyle{u}}}}
\newunicodechar{‚ÇÅ}{\ensuremath{\mathnormal{_1}}}
\newunicodechar{‚ÇÇ}{\ensuremath{\mathnormal{_2}}}
\newunicodechar{‚ÇÉ}{\ensuremath{\mathnormal{_3}}}
\newunicodechar{‚äé}{\ensuremath{\mathnormal\uplus}}
\newunicodechar{‚â°}{\ensuremath{\mathnormal\equiv}}
\newunicodechar{‚âó}{\ensuremath{\mathnormal\circeq}}
\newunicodechar{‚àß}{\ensuremath{\mathnormal\land}}
\newunicodechar{‚â§}{\ensuremath{\mathnormal\leq}}
\newunicodechar{‚àã}{\ensuremath{\mathnormal\ni}}
\newunicodechar{‚Çò}{\ensuremath{\mathnormal{_m}}}
\newunicodechar{‚âü}{\ensuremath{\mathnormal{\stackrel{?}{=}}}}
\newunicodechar{‚à∏}{\ensuremath{\mathnormal\divdot}}
\newunicodechar{‚àé}{\ensuremath{\mathnormal\blacksquare}}
\newunicodechar{‚ü®}{\ensuremath{\mathnormal\langle}}
\newunicodechar{‚ü©}{\ensuremath{\mathnormal\rangle}}
\newunicodechar{ùìÅ}{\ensuremath{\mathnormal{\mathcal l}}}
\newunicodechar{‚Ñì}{\ensuremath{\mathnormal\ell}}
\newunicodechar{œá}{\ensuremath{\mathnormal\chi}}
\newunicodechar{‚äÉ}{\ensuremath{\mathnormal\supset}}
\newunicodechar{‚ñπ}{\ensuremath{\mathnormal\triangleright}}
\newunicodechar{‚äî}{\ensuremath{\mathnormal\sqcup}}
\newunicodechar{‚äì}{\ensuremath{\mathnormal\sqcap}}
\newunicodechar{‚ü≤}{\ensuremath{\mathnormal\circlearrowleft}}
\newunicodechar{ùì´}{\ensuremath{\mathnormal{\mathcal b}}}
\newunicodechar{ùì∞}{\ensuremath{\mathnormal{\mathcal g}}}
\newunicodechar{ùìµ}{\ensuremath{\mathnormal{\mathcal l}}}

\newfontface{\ayyplcihartai}{APL333}
\DeclareTextFontCommand{\ayypl}{\ayyplcihartai}
\newunicodechar{‚åΩ}{\ensuremath{\ayypl ‚åΩ}}

\newcommand\Sym\AgdaSymbol
\newcommand\D\AgdaDatatype
\newcommand\F\AgdaFunction
\newcommand\B\AgdaBound
\newcommand\IC\AgdaInductiveConstructor
\newcommand\OpF[1]{\AgdaOperator{\F{#1}}}

\newcommand\Xr[2]{\textrm{#1(#2)}}

\title{le me'oi .Agda.\ velcki be la'o zoi.\ \Xr{shat}{1} .zoi.\ noi ke'a smimlu la'o zoi.\ \Xr{ed}{1} .zoi.}
\author{la .varik.\ .VALefor.}

\begin{document}
\maketitle

\begin{abstract}
ni'o skicu bau la'oi .Agda.\ fe ko'a goi le milxe be le ka ce'u smimlu be la'o zoi.\ \Xr{ed}{1}\ .zoi.\ pe la'o zoi.\ Version 1 AT\&T UNIX\ .zoi.\ldots kei be'o poi ke'a selcme zoi zoi.\ \Xr{shat}{1}\ .zoi.\ldots ku'o je cu ciksi bau la'oi .Agda.\ le ctaipe be le su'u ko'a co'e ja mapti
\end{abstract}

\tableofcontents

\chapter{le vrici}

\begin{code}
{-# OPTIONS --guardedness #-}
{-# OPTIONS --overlapping-instances #-}
{-# OPTIONS --instance-search-depth=2 #-}

open import IO
  using (
    Main;
    run;
    IO
  )
open import Data.Fin
  as ùîΩ
  using (
    Fin
  )
open import Data.Nat
  as ‚Ñï
  using (
    ‚Ñï
  )
open import Data.Sum
  using (
    from-inj‚ÇÅ;
    map‚ÇÅ;
    inj‚ÇÇ;
    inj‚ÇÅ;
    _‚äé_
  )
open import Function
  using (
    typeOf;
    _on_;
    _‚àò‚ÇÇ_;
    flip;
    _‚àã_;
    _$_;
    _‚àò_;
    id
  )
  renaming (
    _|>_ to _‚ñπ_
  )
open import IO.Finite
  using (
    readFile
  )
open import Data.Bool
  using (
    false;
    T?
  )
  renaming (
    if_then_else_ to if
  )
open import Data.Char
  using (
    isDigit;
    Char
  )
open import Data.List
  as ùïÉ
  using (
    List;
    _‚à∑_;
    []
  )
  renaming (
    lookup to _!_;
    drop to _‚Üì_;
    take to _‚Üë_
  )
open import Data.Maybe
  using (
    decToMaybe;
    from-just;
    nothing;
    Maybe;
    maybe;
    just
  )
open import Data.String
  as ùïä
  using (
    unlines;
    String;
    lines
  )
open import Data.Product
  using (
    uncurry;
    proj‚ÇÇ;
    proj‚ÇÅ;
    _√ó_;
    _,_;
    ‚àÉ;
    Œ£
  )
open import Relation.Unary
  using (
    Decidable;
    Pred
  )
open import Relation.Nullary
  using (
    Dec;
    yes;
    ¬¨_;
    no
  )
open import System.Environment
  using (
    getArgs
  )
open import Truthbrary.Data.Fin
  using (
    mink
  )
open import Truthbrary.Record.Eq
  using (
    _‚â°·µá_;
    _‚âü_
  )
open import Truthbrary.Record.SR
  using (
    readMaybe;
    Show;
    show
  )
open import Data.Unit.Polymorphic
  using (
    ‚ä§
  )
open import Truthbrary.Record.LLC
  using (
    liliList;
    length;
    _++_;
    _‚àâ_;
    cev;
    vec
  )
open import Truthbrary.Category.Monad
  using (
    _<=<_;
    _=<<_;
    _>>=_
  )
  renaming (
    map to map‚Çò
  )
open import Truthbrary.Data.List.Split
  using (
    splitOn
  )
open import Relation.Binary.PropositionalEquality
  using (
    module ‚â°-Reasoning;
    cong;
    refl;
    _‚âó_;
    _‚â°_;
    sym
  )

import Data.Fin.Show
  as ùîΩ
import Agda.Builtin.IO
  as ABIO
import Agda.Builtin.Unit
  as ABU
import Data.Fin.Properties
  as DFP
import Data.Nat.Properties
  as DNP
import Data.List.Properties
  as DLP
import Data.Maybe.Instances
import Data.Maybe.Properties
  as DMP
import Relation.Nullary.Decidable
import Data.List.Relation.Unary.All
  as ùïÉ
  using (
    All
  )
\end{code}

\chapter{le me'oi .instance.\ pe le na se ciksi fo le velcki be le la'o zoi.\ \Xr{shat}{1}\ .zoi.}

\begin{code}
showF : {n : ‚Ñï} ‚Üí Show $ Fin n
showF = record {show = ùîΩ.show}
\end{code}

\chapter{le se ctaipe}

\section{la'oi .\AgdaRecord{Buffer}.}
ni'o ciksi la'oi .\AgdaRecord{Buffer}.\ fo ma poi ke'a zabna ku'o bau la .lojban.

\begin{code}
record Buffer : Set
  where
  field
    datnyveicme : Maybe String
    lerpinste : List String
    cablerpinsle : Fin $ length lerpinste
    citri : List $ Œ£ (typeOf lerpinste) $ Fin ‚àò length
    rejgaudatni : Maybe String
  F = typeOf cablerpinsle
  cninycitri = (lerpinste , cablerpinsle) ‚à∑ citri
\end{code}

\subsection{tu'a la'oi .\D{Fin}.}
ni'o tu'a la'oi .\D{Fin}.\ nibli ko'a goi le su'u ro da poi ke'a ctaipe la'oi .\AgdaRecord{Buffer}.\ zo'u li su'o co'e ja nilzilcmi lo mu'oi zoi.\ \AgdaField{Buffer.lerpinste}\ .zoi.\ be da  .i pilno le co'e co ke na'e me mu'oi zoi.\ \F{if\AgdaUnderscore{}then\AgdaUnderscore{}else\AgdaUnderscore} .zoi.\ ki'u le su'u ko'a milxe ko'e goi le ka ce'u fegli la .varik.\ldots kei je ku'i cu mleca fi ko'e je le ka tu'a ce'u frili kei fe lo jalge be lo nu la'o zoi.\ \AgdaField{Buffer.cablerpinsle} .zoi.\ ctaipe la'o zoi.\ \Sym(\B x \Sym : \AgdaRecord{Buffer}\Sym) \Sym ‚Üí \F{if} \Sym(\AgdaNumber 0 \OpF{‚Ñï.‚â§} \F{length} \Sym(\AgdaField{Buffer.lerpinste} \B x\Sym)\Sym) \Sym(\AgdaField{Buffer.F} \B x\Sym) \D ‚ä§\ .zoi.

\section{la'oi .\D{Cmd}.}
ni'o ctaipe ko'a goi la'o zoi.\ \D{Cmd} \B x\ .zoi.\ fa lo co'e be lo midnoi be fo la'o zoi.\ \Xr{ed}{1} .zoi.\ ja zo'e be'o poi ctaipe lo su'u tu'a ke'a racli

\newcommand\pavysumti[2]{ga je da du la'o zoi.\ \IC{#1} \B v\ .zoi.\ gi da mapti lo konkatena be lo sinxa be la'oi .\B v.\ be'o bei #2}
\newcommand\cibysumti[2]{ga je da du la'o zoi.\ \IC{#1} \B v \B z \AgdaUnderscore{}\ .zoi.\ gi da mapti lo konkatena be lo sinxa be la'oi .\B v.\ be'o bei lo me'oi .comma.\ bei lo sinxa be la'oi .\B z.\ be'o bei #2}
\newcommand\vonsumti[2]{ga je da du la'o zoi.\ \IC{#1} \B v \B x \B z\ \AgdaUnderscore{}\ .zoi.\ gi da mapti lo konkatena be lo sinxa be la'oi .\B v.\ be'o bei lo me'oi .comma.\ bei lo sinxa be la'oi .\B x.\ be'o bei #2\ bei lo sinxa be la'oi .\B z.}
.i ro da poi ke'a ctaipe ko'a zo'u\ldots
\begin{itemize}
	\item ga jonai ga je da du la'oi .\IC{Sisti}.\ gi da mapti zo'oi .q.\ gi
	\item ga jonai ga je da du la'oi .\IC{Sisti!}.\ gi da mapti zo'oi .Q.\ gi
	\item ga jonai ga je da du la'o zoi.\ \IC{Xruti}\ \B z.\ .zoi.\ gi da mapti zo'oi .u.\ldots je ku'i cu mapti le meirmoi be la'oi .\B z.\ bei fo la'o zoi.\ \AgdaField{Buffer.citri} \B x\ .zoi.\ gi
	\item ga jonai \pavysumti{Jmina}{zo'oi .a.}\ gi
	\item ga jonai \pavysumti{Jmini}{zo'oi .i.}\ gi
	\item ga jonai ga je da du la'o zoi.\ \IC{Rejgau} \B v\ .zoi.\ gi da mapti lo konkatena be zo'oi .w.\ bei lo canlu lerfu bei la'oi .\B v.\ gi
	\item ga jonai \cibysumti{Vimcu}{zo'oi .d.} gi
	\item ga jonai \cibysumti{Muvgau}{zo'oi .m.} gi
	\item ga jonai \cibysumti{Cusku}{zo'oi .p.} gi
	\item ga jonai \cibysumti{Namcusku}{zo'oi .n.} gi
	\item \vonsumti{Basti}{zo'oi .c.}
\end{itemize}

\begin{code}
data Cmd (x : Buffer) : Set where
  Sisti : Cmd x
  Sisti! : Cmd x
  Jmina : Buffer.F x ‚Üí Cmd x
  -- | ni'o la .varik. cu cnikansa lo se rigni
  -- be le klamburi
  Jmini : Buffer.F x ‚Üí Cmd x
  Rejgau : String ‚Üí Cmd x
  Vimcu : (a b : Buffer.F x) ‚Üí a ùîΩ.‚â§ b ‚Üí Cmd x
  Namcusku : typeOf Vimcu
  Basti : typeOf Vimcu
  Cusku : typeOf Vimcu
  Muvgau : (a b c : Buffer.F x) ‚Üí a ùîΩ.‚â§ b ‚Üí Cmd x
  Xruti : Fin $ length $ Buffer.citri x ‚Üí Cmd x
\end{code}

\section{la'oi .\D{Cmd·µ¢‚Çí}.}
ni'o ro da poi ke'a ctaipe la'o zoi.\ \D{Cmd·µ¢‚Çí} \B x\ .zoi.\ zo'u\ldots
\begin{itemize}
	\item ga jonai ga je da du la'o zoi.\ \IC{Rejgau·µ¢‚Çí} \B a \B b\ .zoi.\ gi tu'a da rinka lo nu rejgau benji la'oi .\B a.\ lo datnyvei poi ke'a selcme la'oi .\B b.\ gi
	\item ga jonai ga je da du la'o zoi.\ \IC{Tcidu·µ¢‚Çí} \B a \B b\ .zoi.\ gi tu'a da rinka tu'a lo ctaipe be la'oi .\AgdaRecord{Buffer}.\ poi ro de poi ke'a xi pa ctaipe lo me'oi .\F{BufF}.\ be ke'a xi re zo'u ga jonai lo meirmoi be de bei fo ko'e goi lo mu'oi zoi.\ \AgdaField{Buffer.lerpinste}\ .zoi.\ be ke'a cu meirmoi de fo ko'a goi la'o zoi.\ \AgdaField{Buffer.lerpinste} \B x\ .zoi.\ gi ga jonai ga je de zmadu la'oi .\B b.\ je cu dubjavme'a ko'i goi lo nilzilcmi be ko'o goi lo'i ro lerpinsle be lo datnyvei poi ke'a xi re selcme la'oi .\B b.\ gi lo meirmoi be da bei fo ko'e cu meirmoi be lo vujnu be da bei ko'i fo ko'o gi ga je da zmadu la'oi .\B b.\ jenai cu dubjavme'a ko'i gi lo meirmoi be da bei fo ko'e cu meirmoi lo vujnu be da bei la'oi .\B b.\ fo ko'a gi
	\item ga jonai ga je da du la'oi .\IC{Sisti·µ¢‚Çí}.\ gi tu'a da rinka lo nu co'e ja kajde ja cu sisti tu'a la'o zoi.\ \Xr{shat}{1}\ .zoi.\ gi
	\item ga jonai ga je da du la'oi .\IC{Sisti!·µ¢‚Çí}.\ gi tu'a da rinka lo nu sisti tu'a la'o zoi.\ \Xr{shat}{1}\ .zoi.\ gi
	\item ga je da du la'o zoi.\ \IC{Skami·µ¢‚Çí} \B x\ .zoi.\ gi tu'a da rinka lo nu .uniks.\ co'e la'oi .\B x.
\end{itemize}

\begin{code}
data Cmd·µ¢‚Çí (x : Buffer) : Set where
  Rejgau·µ¢‚Çí : String ‚Üí String ‚Üí Cmd·µ¢‚Çí x
  Tcidu·µ¢‚Çí : String ‚Üí Buffer.F x ‚Üí Cmd·µ¢‚Çí x
  Skami·µ¢‚Çí : String ‚Üí Cmd·µ¢‚Çí x
  Sisti·µ¢‚Çí : Cmd·µ¢‚Çí x
  Sisti!·µ¢‚Çí : Cmd·µ¢‚Çí x
\end{code}

\chapter{le fancu}

\section{la'oi .\F{insert}.}
ni'o la .varik.\ na birti lo du'u ma kau zabna je cu lojbo je cu velcki la'oi .\F{insert}.  .i la .varik.\ cu stidi lo nu lo na jimpe cu tcidu le velcki be le ctaipe be le su'u la'oi .\F{insert}.\ mapti

\begin{code}
insert : ‚àÄ {a} ‚Üí {A : Set a}
       ‚Üí (x i : List A)
       ‚Üí Maybe $ Fin $ length x
       ‚Üí List A
insert x i nothing = x ++ i
insert x i (just n) = (n' ‚Üë x) ++ i ++ (n' ‚Üì x)
  where
  n' = ùîΩ.to‚Ñï n
\end{code}

\subsection{le ctaipe be le su'u la'oi .\F{insert}.\ mapti}

\begin{code}
module InsertVeritas where
  private
    lendrop : ‚àÄ {a} ‚Üí {A : Set a}
            ‚Üí (x z : List A)
            ‚Üí z ‚â°_ $ length x ‚Üì_ $ x ++ z
    lendrop [] _ = refl
    lendrop (_ ‚à∑ xs) z = lendrop xs z

    lenteik : ‚àÄ {a} ‚Üí {A : Set a}
            ‚Üí (x z : List A)
            ‚Üí x ‚â°_ $ length x ‚Üë_ $ x ++ z
    lenteik [] _ = refl
    lenteik (x ‚à∑ xs) z = lenteik xs z ‚ñπ cong (x ‚à∑_)

    finlen : ‚àÄ {a} ‚Üí {A : Set a}
           ‚Üí (xs : List A)
           ‚Üí (n : Fin $ length xs)
           ‚Üí ùîΩ.to‚Ñï n ‚â° length (ùîΩ.to‚Ñï n ‚Üë xs)
    finlen (_ ‚à∑ _) ùîΩ.zero = refl
    finlen (_ ‚à∑ xs) (ùîΩ.suc n) = finlen xs n ‚ñπ cong ‚Ñï.suc
       
  lynyrd : ‚àÄ {a} ‚Üí {A : Set a}
         ‚Üí (x i : List A)
         ‚Üí (n : Maybe $ Fin $ length x)
         ‚Üí length x ‚Ñï.+ length i ‚â° length (insert x i n)
  lynyrd x i nothing = DLP.length-++ x ‚ñπ sym
  lynyrd x i (just n) = sym $ begin
    L (insert x i $ just n)
      ‚â°‚ü® refl ‚ü©
    L ((n' ‚Üë x) ++ i ++ (n' ‚Üì x))
      ‚â°‚ü® DLP.length-++ $ n' ‚Üë x ‚ü©
    L (n' ‚Üë x) ‚Ñï.+ L (i ++ (n' ‚Üì x))
      ‚â°‚ü® DLP.length-++ i ‚ñπ cong (‚Ñï._+_ _) ‚ü©
    L (n' ‚Üë x) ‚Ñï.+ (L i ‚Ñï.+ L (n' ‚Üì x))
      ‚â°‚ü® DNP.+-comm (L i) _ ‚ñπ cong (‚Ñï._+_ $ L $ n' ‚Üë x) ‚ü©
    L (n' ‚Üë x) ‚Ñï.+ (L (n' ‚Üì x) ‚Ñï.+ L i)
      ‚â°‚ü® DNP.+-assoc (L $ n' ‚Üë x) _ _ ‚ñπ sym ‚ü©
    L (n' ‚Üë x) ‚Ñï.+ L (n' ‚Üì x) ‚Ñï.+ L i
      ‚â°‚ü® DLP.length-++ (n' ‚Üë x) ‚ñπ sym ‚ñπ cong (‚Ñï._+ L i) ‚ü©
    L (n' ‚Üë x ++ n' ‚Üì x) ‚Ñï.+ L i
      ‚â°‚ü® DLP.take++drop n' x ‚ñπ cong ((‚Ñï._+ L i) ‚àò L) ‚ü©
    L x ‚Ñï.+ L i ‚àé
    where
    L = length
    n' = ùîΩ.to‚Ñï n
    open ‚â°-Reasoning

  pamois : ‚àÄ {a} ‚Üí {A : Set a}
         ‚Üí (x i : List A)
         ‚Üí (n : Maybe $ Fin $ length x)
         ‚Üí let n' = maybe ùîΩ.to‚Ñï (length x) n in
           ((_‚â°_ on (_‚Üë_ n'))
             x
             (insert x i n))
  pamois = {!!}

  remois : ‚àÄ {a} ‚Üí {A : Set a}
         ‚Üí (x i : List A)
         ‚Üí (n : Maybe $ Fin $ length x)
         ‚Üí let n' = maybe ùîΩ.to‚Ñï (length x) n in
           i ‚â°_ $ length i ‚Üë_ $ n' ‚Üì insert x i n
  remois x i nothing = sym $ begin
    L i ‚Üë (L x ‚Üì insert x i nothing) ‚â°‚ü® refl ‚ü©
    L i ‚Üë (L x ‚Üì_ $ x ++ i) ‚â°‚ü® lendrop x i ‚ñπ sym ‚ñπ cong (_ ‚Üë_) ‚ü©
    L i ‚Üë i ‚â°‚ü® DLP.++-identity ≥ i ‚ñπ sym ‚ñπ cong (L i ‚Üë_) ‚ü©
    L i ‚Üë (i ++ []) ‚â°‚ü® lenteik i [] ‚ñπ sym ‚ü©
    i ‚àé
    where
    L = length
    open ‚â°-Reasoning
  remois x i (just n) = sym $ begin
    L i ‚Üë (n' ‚Üì insert x i (just n)) ‚â°‚ü® refl ‚ü©
    L i ‚Üë (n' ‚Üì_ $ x‚ÇÅ ++ i ++ x‚ÇÇ) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® finlen x n ‚ñπ cong (L i ‚Üë_ ‚àò flip _‚Üì_ (x‚ÇÅ ++ i ++ x‚ÇÇ)) ‚ü©
    L i ‚Üë (L x‚ÇÅ ‚Üì_ $ x‚ÇÅ ++ i ++ x‚ÇÇ) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® lendrop x‚ÇÅ _ ‚ñπ sym ‚ñπ cong (_ ‚Üë_) ‚ü©
    L i ‚Üë (i ++ x‚ÇÇ) ‚â°‚ü® lenteik i x‚ÇÇ ‚ñπ sym ‚ü©
    i ‚àé
    where
    L = length
    n' = ùîΩ.to‚Ñï n
    x‚ÇÅ = n' ‚Üë x
    x‚ÇÇ = n' ‚Üì x
    open ‚â°-Reasoning

  romois : ‚àÄ {a} ‚Üí {A : Set a}
         ‚Üí (x i : List A)
         ‚Üí (n : Maybe $ Fin $ length x)
         ‚Üí let n' = maybe ùîΩ.to‚Ñï (length x) n in
           n' ‚Üì x ‚â° (n' ‚Ñï.+ length i) ‚Üì insert x i n
  romois = {!!}
\end{code}

\section{la'o zoi.\ \F{\AgdaUnderscore{},‚Çò\AgdaUnderscore}\ .zoi.}
ni'o xu sarcu fa lo nu ciksi bau la .lojban.

\begin{code}
_,‚Çò_ : ‚àÄ {a} ‚Üí {A B : Set a}
     ‚Üí Maybe A ‚Üí Maybe B ‚Üí Maybe $ A √ó B
_,‚Çò_ = Data.Maybe.ap ‚àò‚ÇÇ map‚Çò $ _,_
\end{code}

\section{la'o zoi.\ \F{dec-just}\ .zoi.}
ni'o la .varik.\ na jinvi le du'u sarcu fa lo nu ciksi fo lo lojbo fe la'o zoi.\ \F{dec-just}\ .zoi.

\begin{code}
dec-just : ‚àÄ {a p} ‚Üí {A : Set a}
         ‚Üí {P : Pred A p}
         ‚Üí {x : A}
         ‚Üí {P? : Dec $ P x}
         ‚Üí (m : P x)
         ‚Üí ‚àÉ $ Œª m ‚Üí decToMaybe P? ‚â° just m
dec-just {P? = P?} m = Data.Product.dmap id (cong decToMaybe) M
  where
  M = Relation.Nullary.Decidable.dec-yes P? m
\end{code}

\section{la'o zoi.\ \F{dec-nothing}\ .zoi.}
ni'o la .varik.\ na jinvi le du'u sarcu fa lo nu ciksi fo lo lojbo fe la'o zoi.\ \F{dec-nothing}\ .zoi.

\begin{code}
dec-nothing : ‚àÄ {a p} ‚Üí {A : Set a}
            ‚Üí {P : Pred A p}
            ‚Üí {x : A}
            ‚Üí {P? : Dec $ P x}
            ‚Üí (m : ¬¨ P x)
            ‚Üí decToMaybe P? ‚â° nothing
dec-nothing {P? = P?} m = begin
  decToMaybe P? ‚â°‚ü® M ‚ñπ proj‚ÇÇ ‚ñπ cong decToMaybe ‚ü©
  decToMaybe (no $ proj‚ÇÅ M) ‚â°‚ü® refl ‚ü©
  nothing ‚àé
  where
  M = Relation.Nullary.Decidable.dec-no P? m
  open ‚â°-Reasoning
\end{code}

\section{la \F{dekydu'i}}
ni'o xu sarcu fa lo nu la .varik.\ cu ciksi la \F{dekydu'i} bau la .lojban.

\begin{code}
dekydu'i : {x n : ‚Ñï}
         ‚Üí {m : x ‚Ñï.< n}
         ‚Üí decToMaybe (x ‚Ñï.<? n) ‚â° just m
dekydu'i {x} {n} {m} = begin
  decToMaybe (x ‚Ñï.<? n) ‚â°‚ü® DY ‚ñπ proj‚ÇÇ ‚ñπ cong decToMaybe ‚ü©
  decToMaybe (yes $ proj‚ÇÅ DY) ‚â°‚ü® refl ‚ü©
  _ ‚â°‚ü® iedek (proj‚ÇÅ DY) m ‚ñπ cong (decToMaybe ‚àò yes) ‚ü©
  decToMaybe (yes m) ‚â°‚ü® refl ‚ü©
  just m ‚àé
  where
  DY = Relation.Nullary.Decidable.dec-yes (x ‚Ñï.<? n) m
  iedek : {m n : ‚Ñï} ‚Üí (x z : m ‚Ñï.< n) ‚Üí x ‚â° z
  iedek (‚Ñï.s‚â§s ‚Ñï.z‚â§n) (‚Ñï.s‚â§s ‚Ñï.z‚â§n) = refl
  iedek {‚Ñï.suc m} {‚Ñï.suc n} (‚Ñï.s‚â§s x) (‚Ñï.s‚â§s z) = I
    where
    I = iedek {m} {n} x z ‚ñπ cong ‚Ñï.s‚â§s
  open ‚â°-Reasoning
\end{code}

\section{la \F{zmadekydu'i}}

\begin{code}
zmadekydu'i : {x n : ‚Ñï}
            ‚Üí {m : x ‚Ñï.‚â§ n}
            ‚Üí decToMaybe (x ‚Ñï.‚â§? n) ‚â° just m
zmadekydu'i {x} {n} {m} = begin
  decToMaybe (x ‚Ñï.‚â§? n) ‚â°‚ü® DY ‚ñπ proj‚ÇÇ ‚ñπ cong decToMaybe ‚ü©
  decToMaybe (yes $ proj‚ÇÅ DY) ‚â°‚ü® refl ‚ü©
  _ ‚â°‚ü® iedek (proj‚ÇÅ DY) m ‚ñπ cong (decToMaybe ‚àò yes) ‚ü©
  decToMaybe (yes m) ‚â°‚ü® refl ‚ü©
  just m ‚àé
  where
  DY = Relation.Nullary.Decidable.dec-yes (x ‚Ñï.‚â§? n) m
  iedek : {m n : ‚Ñï} ‚Üí (x z : m ‚Ñï.‚â§ n) ‚Üí x ‚â° z
  iedek ‚Ñï.z‚â§n ‚Ñï.z‚â§n = refl
  iedek {‚Ñï.suc m} {‚Ñï.suc n} (‚Ñï.s‚â§s x) (‚Ñï.s‚â§s z) = I
    where
    I = iedek {m} {n} x z ‚ñπ cong ‚Ñï.s‚â§s
  open ‚â°-Reasoning
\end{code}

\section{la'oi .\F{from‚Ñï?}.}
ni'o ga jonai la'oi .\IC{nothing}.\ du ko'a goi la'o zoi.\ \F{from‚Ñï?}\ \B x\ .zoi.\ gi la'o zoi.\ \F{map‚Çò} \F{ùîΩ.to‚Ñï} \OpF \$ \F{from‚Ñï?}\ \B x\ .zoi.\ me'oi .\IC{just}.\ zo'e poi la'oi .\B x.\ mu'oi zoi.\ \F{ùîΩ.to‚Ñï}\ .zoi.\ ke'a

\begin{code}
from‚Ñï? : {n : ‚Ñï} ‚Üí ‚Ñï ‚Üí Maybe $ Fin n
from‚Ñï? = map‚Çò ùîΩ.from‚Ñï< ‚àò decToMaybe ‚àò (‚Ñï._<? _)
\end{code}

\subsection{le ctaipe be le su'u la'oi .\F{from‚Ñï?}.\ mapti}

\begin{code}
module from‚Ñï?Veritas where
  pav : {n : ‚Ñï}
      ‚Üí (x : ‚Ñï)
      ‚Üí x ‚Ñï.< n
      ‚Üí just x ‚â° map‚Çò ùîΩ.to‚Ñï (from‚Ñï? {n} x)
  pav {n} x m = sym $ begin
    map‚Çò ùîΩ.to‚Ñï (from‚Ñï? {n} x) ‚â°‚ü® refl ‚ü©
    map‚Çò ùîΩ.to‚Ñï (map‚Çò ùîΩ.from‚Ñï< $ c? x) ‚â°‚ü® mapmapi $ c? x ‚ü©
    map‚Çò id' (c? x) ‚â°‚ü® dekydu'i ‚ñπ cong (map‚Çò id') ‚ü©
    map‚Çò id' (just m) ‚â°‚ü® refl ‚ü©
    just (id' m) ‚â°‚ü® DFP.to‚Ñï-from‚Ñï< m ‚ñπ cong just ‚ü©
    just x ‚àé
    where
    id' = ùîΩ.to‚Ñï ‚àò ùîΩ.from‚Ñï<
    c? : (x : ‚Ñï) ‚Üí Maybe $ x ‚Ñï.< n
    c? = decToMaybe ‚àò (‚Ñï._<? n)
    open ‚â°-Reasoning
    mapmapi = sym ‚àò DMP.map-compose

  rel : {n : ‚Ñï}
      ‚Üí (x : ‚Ñï)
      ‚Üí ¬¨_ $ x ‚Ñï.< n
      ‚Üí nothing ‚â° map‚Çò ùîΩ.to‚Ñï (from‚Ñï? {n} x)
  rel {n} x J = sym $ begin
    map‚Çò ùîΩ.to‚Ñï (from‚Ñï? {n} x) ‚â°‚ü® refl ‚ü©
    map‚Çò ùîΩ.to‚Ñï (map‚Çò ùîΩ.from‚Ñï< $ decToMaybe $ x ‚Ñï.<? n) ‚â°‚ü® {!!} ‚ü©
    map‚Çò (ùîΩ.to‚Ñï ‚àò ùîΩ.from‚Ñï<) (decToMaybe $ x ‚Ñï.<? n) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® DN ‚ñπ proj‚ÇÇ ‚ñπ cong (map‚Çò (ùîΩ.to‚Ñï ‚àò ùîΩ.from‚Ñï<) ‚àò decToMaybe) ‚ü©
    map‚Çò (ùîΩ.to‚Ñï ‚àò ùîΩ.from‚Ñï<) (decToMaybe $ no N) ‚â°‚ü® refl ‚ü©
    nothing ‚àé
    where
    DN = Relation.Nullary.Decidable.dec-no (x ‚Ñï.<? n) J
    N = ¬¨ (x ‚Ñï.< n) ‚àã proj‚ÇÅ DN
    open ‚â°-Reasoning
\end{code}

\section{la'oi .\F{degjygirzu}.}
ni'o la .varik.\ na birti lo du'u ciksi bau la .lojban.\ fe la \F{degjygirzu}\ fo ma kau poi ke'a zabna

\begin{code}
degjygirzu : String ‚Üí List String
degjygirzu = ùïä.wordsBy $ T? ‚àò Data.Bool.not ‚àò isDigit
\end{code}

\subsection{le ctaipe be le su'u la \F{degjygirzu}\ cu mapti}

\begin{code}
module DegjygirzuVeritas where
  pav : ((x : String) ‚Üí x ‚â° ùïä.fromList (ùïä.toList x))
      ‚Üí (n : ‚Ñï) ‚Üí degjygirzu (show n) ‚â° show n ‚à∑ []
  pav fL‚àòtL n = begin
    degjygirzu (show n) ‚â°‚ü® refl ‚ü©
    ùïÉ.map ùïä.fromList (d $ ùïä.toList $ show n) ‚â°‚ü® refl ‚ü©
    mL (d $ show' n) ‚â°‚ü® didus n ‚ñπ cong mL ‚ü©
    mL (show' n ‚à∑ []) ‚â°‚ü® fL‚àòtL (show n) ‚ñπ sym ‚ñπ cong (_‚à∑ []) ‚ü©
    show n ‚à∑ [] ‚àé
    where
    mL = ùïÉ.map ùïä.fromList
    show' = ùïä.toList ‚àò show
    d = ùïÉ.wordsBy $ T? ‚àò Data.Bool.not ‚àò isDigit
    didus : (n : ‚Ñï) ‚Üí d (show' n) ‚â° show' n ‚à∑ []
    didus = {!!}
    open ‚â°-Reasoning

  rybic : (s : String)
        ‚Üí (c : Char)
        ‚Üí false ‚â° isDigit c
        ‚Üí (_‚â°_
            (degjygirzu s)
            (degjygirzu $ ùïä.fromChar c ++ s))
  rybic s c j = sym $ begin
    degjygirzu (ùïä.fromChar c ++ s) ‚â°‚ü® refl ‚ü©
    degjygirzu (fC c ++ s) ‚â°‚ü® refl ‚ü©
    d' (tL $ fC c ++ s) ‚â°‚ü® tldist (fC c) s ‚ñπ cong d' ‚ü©
    d' (tL (fC c) ++ tL s) ‚â°‚ü® tilfic c ‚ñπ cong (d' ‚àò (_++ tL s)) ‚ü©
    d' ((c ‚à∑ []) ++ tL s) ‚â°‚ü® refl ‚ü©
    d' (c ‚à∑ tL s) ‚â°‚ü® refl ‚ü©
    ùïÉ.map fL (ùïÉ.wordsBy (F? ‚àò isDigit) $ c ‚à∑ tL s) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® uobis c (tL s) (fineg j) ‚ñπ cong (ùïÉ.map fL) ‚ü©
    ùïÉ.map fL (ùïÉ.wordsBy (F? ‚àò isDigit) $ tL s) ‚â°‚ü® refl ‚ü©
    degjygirzu s ‚àé
    where
    tL = ùïä.toList
    fL = ùïä.fromList
    fC = ùïä.fromChar
    F? = T? ‚àò Data.Bool.not
    tldist : (x z : String) ‚Üí tL (x ++ z) ‚â° tL x ++ tL z
    tldist = {!!}
    -- | .i cicna finpe
    tilfic : tL ‚àò fC ‚âó ùïÉ.[_]
    tilfic = {!!}
    d' = ùïÉ.map fL ‚àò_ $ ùïÉ.wordsBy $ F? ‚àò isDigit
    fineg : {x : Data.Bool.Bool}
          ‚Üí false ‚â° x
          ‚Üí Data.Bool.T $ Data.Bool.not x
    fineg refl = _
    open ‚â°-Reasoning
    uobis : ‚àÄ {a p} ‚Üí {A : Set a}
          ‚Üí {P : Pred A p}
          ‚Üí {P? : Decidable P}
          ‚Üí (x : A)
          ‚Üí (xs : List A)
          ‚Üí P x
          ‚Üí ùïÉ.wordsBy P? (x ‚à∑ xs) ‚â° ùïÉ.wordsBy P? xs
    uobis = {!!}

  rel : (s : String)
      ‚Üí (t : ‚Ñï)
      ‚Üí (c : Char)
      ‚Üí false ‚â° isDigit c
      ‚Üí (_‚â°_
          (show t ‚à∑ degjygirzu s)
          (degjygirzu $ show t ++ ùïä.fromChar c ++ s))
  rel s t c j = sym $ begin
    d (show t ++ ùïä.fromChar c ++ s) ‚â°‚ü® {!!} ‚ü©
    d (show t) ++ d (ùïä.fromChar c ++ s) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® rybic s c j ‚ñπ sym ‚ñπ cong (_++_ _) ‚ü©
    d (show t) ++ d s ‚â°‚ü® pav (sym ‚àò fL‚àòtL) t ‚ñπ cong (_++ d s) ‚ü©
    (show t ‚à∑ []) ++ d s ‚â°‚ü® refl ‚ü©
    show t ‚à∑ d s ‚àé
    where
    d = degjygirzu
    tL = ùïä.toList
    fL = ùïä.fromList
    tildist : (x z : String) ‚Üí tL (x ++ z) ‚â° tL x ++ tL z
    tildist = {!!}
    d' = ùïÉ.map fL ‚àò_ $ ùïÉ.wordsBy $ T? ‚àò Data.Bool.not ‚àò isDigit
    fL‚àòtL = {!!}
    open ‚â°-Reasoning
\end{code}

\section{la'oi .\F{pamoinamcu}.}
ni'o ro da xi pa poi ke'a na'e degji lerfu zo'u ro da xi re poi ke'a ctaipe la'oi .\AgdaPostulate{String}.\ zo'u ga jonai la'oi .\IC{nothing}.\ du ko'a goi la'o zoi.\ \F{pamoinamcu} \B x\ .zoi.\ gi su'o de poi ke'a kacna'u zo'u ga je la'oi .\B x.\ konkatena lo sinxa be de bei de xi pa bei de xi re gi ko'a de me'oi .\IC{just}.

\begin{code}
pamoinamcu : String ‚Üí Maybe ‚Ñï
pamoinamcu = readMaybe <=< (ùïÉ.head ‚àò degjygirzu)
\end{code}

\subsection{le ctaipe be le su'u mapti fa la'oi .\F{pamoinamcu}.}

\begin{code}
module PamoinamcuVeritas where
  non : ((n : ‚Ñï) ‚Üí readMaybe (show n) ‚â° just n)
      ‚Üí ((x : String) ‚Üí x ‚â° ùïä.fromList (ùïä.toList x))
      ‚Üí (n : ‚Ñï) ‚Üí just n ‚â° pamoinamcu (show n)
  non rimco fL‚àòtL n = sym $ begin
    pamoinamcu (show n) ‚â°‚ü® refl ‚ü©
    ùïÉ.head (s $ show n) >>= readMaybe ‚â°‚ü® refl ‚ü©
    ùì∞ (s $ show n) ‚â°‚ü® DegjygirzuVeritas.pav fL‚àòtL n ‚ñπ cong ùì∞ ‚ü©
    ùì∞ (show n ‚à∑ []) ‚â°‚ü® refl ‚ü©
    ùïÉ.head (show n ‚à∑ []) >>= readMaybe ‚â°‚ü® refl ‚ü©
    readMaybe (show n) ‚â°‚ü® rimco n ‚ü©
    just n ‚àé
    where
    ùì∞ = readMaybe <=< ùïÉ.head
    s = ùïä.wordsBy $ T? ‚àò Data.Bool.not ‚àò Data.Char.isDigit
    open ‚â°-Reasoning

  pav : ((n : ‚Ñï) ‚Üí readMaybe (show n) ‚â° just n)
      ‚Üí (n : ‚Ñï)
      ‚Üí (c : Char)
      ‚Üí (s : String)
      ‚Üí false ‚â° isDigit c
      ‚Üí just n ‚â° pamoinamcu (show n ++ ùïä.fromChar c ++ s)
  pav rimco n c t j = sym $ begin
   pamoinamcu (show n ++ c' ++ t) ‚â°‚ü® refl ‚ü©
   ùïÉ.head (d $ show n ++ c' ++ t) >>= readMaybe ‚â°‚ü® refl ‚ü©
   ùì∞ (d $ show n ++ c' ++ t) ‚â°‚ü® dvr t n c j ‚ñπ sym ‚ñπ cong ùì∞ ‚ü©
   ùì∞ (show n ‚à∑ d (c' ++ t)) ‚â°‚ü® refl ‚ü©
   ùïÉ.head (show n ‚à∑ d (c' ++ t)) >>= readMaybe ‚â°‚ü® refl ‚ü©
   readMaybe (show n) ‚â°‚ü® rimco n ‚ü©
   just n ‚àé
   where
   dvr = DegjygirzuVeritas.rel
   c' = ùïä.fromChar c
   ùì∞ = readMaybe <=< ùïÉ.head
   d = degjygirzu
   open ‚â°-Reasoning
\end{code}

\section{la'oi .\F{romoivimcu}.}
ni'o la .varik.\ na birti lo du'u ciksi la'oi .\F{romoivimcu}.\ fo ma kau poi ke'a zabna je cu te gerna la .lojban.

\begin{code}
romoivimcu : String ‚Üí String
romoivimcu = S $ Œª n ‚Üí _‚Üë n $ ùïÉ.length n ‚Ñï.‚à∏ 1
  where
  S = Œª f ‚Üí ùïä.fromList ‚àò f ‚àò ùïä.toList
\end{code}

\subsection{le ctaipe be le su'u la'oi .\F{romoivimcu}.\ mapti}

\begin{code}
module RomoivimcuVeritas where
  pav : (x : String)
      ‚Üí let -1‚Üëx = ùïä.fromList $ (length x ‚Ñï.‚à∏ 1) ‚Üì_ $ ùïä.toList x in
        x ‚â° romoivimcu x ++ -1‚Üëx
  pav x = sym $ begin
    romoivimcu x ++ ùïä.fromList r ‚â°‚ü® refl ‚ü©
    ùïä.fromList (_‚Üë x' $ length x' ‚Ñï.‚à∏ 1) ++ ùïä.fromList r ‚â°‚ü® refl ‚ü©
    ùïä.fromList -1‚Üìx' ++ ùïä.fromList r ‚â°‚ü® frokonk -1‚Üìx' r ‚ü©
    ùïä.fromList (-1‚Üìx' ++ r) ‚â°‚ü® refl ‚ü©
    ùïä.fromList x'' ‚â°‚ü® x''‚â°x' ‚ñπ cong ùïä.fromList ‚ü©
    ùïä.fromList x' ‚â°‚ü® [cev‚àòvec]¬≤ x ‚ñπ sym ‚ü©
    x ‚àé
    where
    x' = ùïä.toList x
    r = _‚Üì x' $ length x' ‚Ñï.‚à∏ 1
    -1‚Üìx' = _‚Üë x' $ length x' ‚Ñï.‚à∏ 1
    x'' = -1‚Üìx' ++ r
    x''‚â°x' : x'' ‚â° x'
    x''‚â°x' = DLP.take++drop (length x' ‚Ñï.‚à∏ 1) x'
    frokonk : (a b : List Char)
            ‚Üí (_‚â°_
                (ùïä.fromList a ++ ùïä.fromList b)
                (ùïä.fromList $ a ++ b))
    frokonk = {!!}
    [cev‚àòvec]¬≤ : (x : String) ‚Üí x ‚â° ùïä.fromList (ùïä.toList x)
    [cev‚àòvec]¬≤ = {!!}
    open ‚â°-Reasoning
\end{code}

\section{la'oi .\F{orsygenturfa'i}.}
ni'o ro da poi ke'a ctaipe ko'a goi la'o zoi.\ \D{Fin} \B n\ .zoi.\ zo'u ro de poi ke'a ctaipe ko'a zo'u ga jonai la'oi .\IC{nothing}.\ du ko'a goi la'o zoi.\ \F{orsygenturfa'i} \B s\ .zoi.\ gi ga je da dubjavme'a de gi ga je ko'a me'oi .\IC{just}.\ lo .orsi be li re bei lo .orsi be li re bei da bei de be'o bei lo ctaipe be lo su'u da dubjavme'a de gi la'oi .\B s.\ konkatena lo sinxa be da lo me'oi .comma.\ lo sinxa be de

\begin{code}
module Orsygenturfa'i where
  ps : {n : ‚Ñï} ‚Üí List Char ‚Üí Maybe $ Fin n
  ps = from‚Ñï? <=< (readMaybe ‚àò ùïä.fromList)

  spit : String ‚Üí List $ List Char
  spit = ùïÉ.wordsBy (_‚âü ',') ‚àò ùïä.toList

  pork : {n : ‚Ñï}
       ‚Üí List $ Maybe $ Fin n
       ‚Üí Maybe $ Œ£ (Fin n √ó Fin n) $ uncurry ùîΩ._‚â§_
  pork (just a ‚à∑ just b ‚à∑ []) = map‚Çò (_ ,_) $ decToMaybe $ a ùîΩ.‚â§? b
  pork _ = nothing

  orsygenturfa'i : {n : ‚Ñï}
                 ‚Üí String
                 ‚Üí Maybe $ Œ£ (Fin n √ó Fin n) $ uncurry ùîΩ._‚â§_
  orsygenturfa'i = pork ‚àò ùïÉ.map ps ‚àò spit

open Orsygenturfa'i
  using (
    orsygenturfa'i
  )
\end{code}

\subsection{le krinu be le me'oi .\AgdaKeyword{module}.\ co'e}
ni'o pilno ko'a goi le me'oi .\AgdaKeyword{module}.\ co'e ki'u le su'u tu'a ko'a filri'a lo nu ciksi lo ctaipe be le su'u mapti  .i la .varik.\ na jinvi le du'u sarcu fa lo nu ciksi lo steci be la'oi .\F{orgenturfa'i}.\ jenai zo'e bau la .lojban.

\subsection{le ctaipe be le su'u la'oi .\F{orsygenturfa'i}.\ mapti}

\begin{code}
module Orsygenturfa'iVeritas where
  open Orsygenturfa'i

  spit-non : (x : String) ‚Üí ',' ‚àâ ùïä.toList x ‚Üí spit x ‚â° ùïä.toList x ‚à∑ []
  spit-non = {!!}

  spit-du : (x z : String)
          ‚Üí ',' ‚àâ ùïä.toList x
          ‚Üí ',' ‚àâ ùïä.toList z
          ‚Üí (_‚â°_
              (spit $ x ++ "," ++ z)
              (ùïä.toList x ‚à∑ ùïä.toList z ‚à∑ []))
  spit-du x z inx inz = begin
    spit (x ++ "," ++ z) ‚â°‚ü® refl ‚ü©
    w (tL $ x ++ "," ++ z) ‚â°‚ü® tildist x ("," ++ z) ‚ñπ cong w ‚ü©
    w (tL x ++ tL ("," ++ z)) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® tildist "," z ‚ñπ cong (w ‚àò _++_ (tL x)) ‚ü©
    w (tL x ++ tL "," ++ tL z) ‚â°‚ü® refl ‚ü©
    w (tL x ++ ',' ‚à∑ tL z) ‚â°‚ü® uit _ (tL x) _ (F inx) (F inz) _ refl ‚ü©
    w (tL x) ++ w (tL z) ‚â°‚ü® spit-non x inx ‚ñπ cong (_++ _) ‚ü©
    (tL x ‚à∑ []) ++ w (tL z) ‚â°‚ü® spit-non z inz ‚ñπ cong (_++_ _) ‚ü©
    (tL x ‚à∑ []) ++ (tL z ‚à∑ []) ‚â°‚ü® refl ‚ü©
    tL x ‚à∑ tL z ‚à∑ [] ‚àé
    where
    tL = ùïä.toList
    w = ùïÉ.wordsBy $ _‚âü ','
    tildist : (x z : String) ‚Üí tL (x ++ z) ‚â° tL x ++ tL z
    tildist = {!!}
    F : ‚àÄ {a} ‚Üí {A : Set a}
      ‚Üí ‚¶É _ : Truthbrary.Record.Eq.Eq A ‚¶Ñ
      ‚Üí {e : A}
      ‚Üí {x : List A}
      ‚Üí e ‚àâ x
      ‚Üí ùïÉ.All (¬¨_ ‚àò (_‚â° e)) x
    F = {!!}
    uit : ‚àÄ {a p} ‚Üí {A : Set a} ‚Üí {P : Pred A p}
        ‚Üí (P? : Decidable P)
        ‚Üí (x z : List A)
        ‚Üí ùïÉ.All (¬¨_ ‚àò P) x
        ‚Üí ùïÉ.All (¬¨_ ‚àò P) z
        ‚Üí (e : A)
        ‚Üí P e
        ‚Üí (_‚â°_
            (ùïÉ.wordsBy P? $ x ++ e ‚à∑ z)
            (ùïÉ.wordsBy P? x ++ ùïÉ.wordsBy P? z))
    uit = {!!}
    open ‚â°-Reasoning

  ps-du : ((x : ‚Ñï) ‚Üí readMaybe (show x) ‚â° just x)
        ‚Üí {n : ‚Ñï}
        ‚Üí (x : Fin n)
        ‚Üí just x ‚â° ps (ùïä.toList $ show $ ùîΩ.to‚Ñï x)
  ps-du rimco x = sym $ begin
    ps (ùïä.toList $ show x) ‚â°‚ü® refl ‚ü©
    bùîΩ (rM $ id' $ show x) ‚â°‚ü® cvd x ‚ñπ cong (bùîΩ ‚àò readMaybe) ‚ü©
    bùîΩ (rM $ show x) ‚â°‚ü® rimco (ùîΩ.to‚Ñï x) ‚ñπ cong bùîΩ ‚ü©
    bùîΩ (just $ ùîΩ.to‚Ñï x) ‚â°‚ü® refl ‚ü©
    just (ùîΩ.to‚Ñï x) >>= from‚Ñï? ‚â°‚ü® refl ‚ü©
    from‚Ñï? (ùîΩ.to‚Ñï x) ‚â°‚ü® refl ‚ü©
    map‚Çò ùîΩ.from‚Ñï< (decToMaybe $ _ ‚Ñï.<? _) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® zmadekydu'i ‚ñπ cong (map‚Çò ùîΩ.from‚Ñï<) ‚ü©
    map‚Çò ùîΩ.from‚Ñï< (just $ DFP.to‚Ñï<n x) ‚â°‚ü® refl ‚ü©
    just _ ‚â°‚ü® DFP.from‚Ñï<-to‚Ñï _ _ ‚ñπ cong just ‚ü©
    just x ‚àé
    where
    rM = readMaybe
    bùîΩ = _>>= from‚Ñï?
    id' = ùïä.fromList ‚àò ùïä.toList
    open ‚â°-Reasoning
    cvd : {n : ‚Ñï} ‚Üí (x : Fin n) ‚Üí id' (show x) ‚â° show x
    cvd x = istu $ show x
      where
      istu : (x : String) ‚Üí id' x ‚â° x
      istu = {!!}

  ps-nada : (j : String)
          ‚Üí ¬¨_ $ Œ£ (‚àÉ Fin) $ _‚â°_ j ‚àò show ‚àò proj‚ÇÇ
          ‚Üí {n : ‚Ñï}
          ‚Üí nothing ‚â° ps {n = n} (ùïä.toList j)
  ps-nada = {!!}

  pork-du : {n : ‚Ñï}
          ‚Üí {x z : Fin n}
          ‚Üí (djb : x ùîΩ.‚â§ z)
          ‚Üí (_‚â°_
              (pork $ just x ‚à∑ just z ‚à∑ [])
              (just $ (x , z) , djb))
  pork-du {n} {x} {z} djb = begin
    pork (just x ‚à∑ just z ‚à∑ []) ‚â°‚ü® refl ‚ü©
    map‚Çò (_ ,_) (decToMaybe $ x ùîΩ.‚â§? z) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® zmadekydu'i {m = djb} ‚ñπ cong (map‚Çò (_ ,_)) ‚ü©
    map‚Çò (_ ,_) (just djb) ‚â°‚ü® refl ‚ü©
    just ((x , z) , djb) ‚àé
    where
    open ‚â°-Reasoning

  pork-nada : {n : ‚Ñï}
            ‚Üí {x z : Fin n}
            ‚Üí ¬¨_ $ x ùîΩ.‚â§ z
            ‚Üí pork (just x ‚à∑ just z ‚à∑ []) ‚â° nothing
  pork-nada {_} {x} {z} j = begin
    pork (just x ‚à∑ just z ‚à∑ []) ‚â°‚ü® refl ‚ü©
    map‚Çò (_ ,_) (decToMaybe $ x ùîΩ.‚â§? z) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® DN ‚ñπ proj‚ÇÇ ‚ñπ cong (map‚Çò (_ ,_) ‚àò decToMaybe) ‚ü©
    map‚Çò (_ ,_) (decToMaybe $ no $ proj‚ÇÅ DN) ‚â°‚ü® refl ‚ü©
    nothing ‚àé
    where
    DN = Relation.Nullary.Decidable.dec-no (x ùîΩ.‚â§? z) j
    open ‚â°-Reasoning

  pav : ((x : ‚Ñï) ‚Üí readMaybe (show x) ‚â° just x)
      ‚Üí {n : ‚Ñï}
      ‚Üí (a b : Fin n)
      ‚Üí (djb : a ùîΩ.‚â§ b)
      ‚Üí (_‚â°_
          (orsygenturfa'i $ show a ++ "," ++ show b)
          (just $ (a , b) , djb))
  pav rimco a b djb = begin
    orsygenturfa'i (show a ++ "," ++ show b) ‚â°‚ü® refl ‚ü©
    pork (ùïÉ.map ps $ spit a,b) ‚â°‚ü® cong pork mapyjus ‚ü©
    pork (just a ‚à∑ just b ‚à∑ []) ‚â°‚ü® pork-du djb ‚ü©
    just ((a , b) , djb) ‚àé
    where
    a,b = show a ++ "," ++ show b

    open ‚â°-Reasoning
    mapyjus = begin
      ùïÉ.map ps (spit a,b) ‚â°‚ü® spidus a b ‚ñπ cong (ùïÉ.map ps) ‚ü©
      ùïÉ.map ps (showF' a ‚à∑ showF' b ‚à∑ []) ‚â°‚ü® refl ‚ü©
      ùïÉ.map justF' (a ‚à∑ b ‚à∑ []) ‚â°‚ü® justymapdu $ a ‚à∑ b ‚à∑ [] ‚ü©
      ùïÉ.map just (a ‚à∑ b ‚à∑ []) ‚â°‚ü® refl ‚ü©
      just a ‚à∑  just b ‚à∑ [] ‚àé
      where
      showF' : {n : ‚Ñï} ‚Üí Fin n ‚Üí List Char
      showF' = ùïä.toList ‚àò show
      justF' : {n : ‚Ñï} ‚Üí Fin n ‚Üí Maybe $ Fin n
      justF' = ps ‚àò showF'
      justF'‚â°just : {n : ‚Ñï} ‚Üí (x : Fin n) ‚Üí justF' x ‚â° just x
      justF'‚â°just x = sym $ ps-du rimco x
      justymapdu : {n : ‚Ñï}
                 ‚Üí (L : List $ Fin n)
                 ‚Üí ùïÉ.map justF' L ‚â° ùïÉ.map just L
      justymapdu = DLP.map-cong justF'‚â°just
      spidus : {n : ‚Ñï}
             ‚Üí (a b : Fin n)
             ‚Üí (_‚â°_
                 (spit $ show a ++ "," ++ show b)
                 (showF' a ‚à∑ showF' b ‚à∑ []))
      spidus a b = spit-du (show a) (show b) (nokom a) (nokom b)
        where
        nokom : {n : ‚Ñï} ‚Üí (x : Fin n) ‚Üí ',' ‚àâ ùïä.toList (show x)
        nokom = {!!}
\end{code}

\section{la'oi .\F{orsygenturfa'i‚ÇÉ}.}
ni'o ro da xi pa poi ke'a ctaipe ko'a goi la'o zoi.\ \D{Fin} \B n\ .zoi.\ zo'u ro da xi re poi ke'a ctaipe ko'a zo'u do da xi ci poi ke'a ctaipe ko'a zo'u ro de poi ctaipe lo su'u ke'a cmima lo'i ro lerfu po le glibau ge'u poi ke'a me'oi .minuscule.\ zo'u ga jonai ko'e goi la'o zoi.\ \F{orsygenturfa'i‚ÇÉ} \B x\ .zoi.\ du la'oi .\IC{nothing}.\ gi ga je la'oi .\B x.\ konkatena lo sinxa be da xi pa lo me'oi .comma.\ lo sinxa be da xi re de lo sinxa be da xi ci gi ko'e me'oi .\IC{just}.\ lo .orsi be li re bei lo .orsi be li re bei lo .orsi be li re bei da xi pa bei da xi re be'o bei zo'e be'o bei da xi ci

\begin{code}
module Orsygenturfa'i‚ÇÉ where
  lispork : List $ List String ‚Üí Maybe $ (String √ó String) √ó String
  lispork ((a ‚à∑ []) ‚à∑ (b ‚à∑ c ‚à∑ []) ‚à∑ []) = just $ (a , b) , c
  lispork _ = nothing

  orsispita : String ‚Üí Maybe $ (String √ó String) √ó String
  orsispita = lispork ‚àò ùïÉ.map (w aintDigit?) ‚àò w (_‚âü ',')
    where
    w = ùïä.wordsBy
    aintDigit? = T? ‚àò Data.Bool.not ‚àò isDigit

  pork : {n : ‚Ñï}
       ‚Üí (String √ó String) √ó String
       ‚Üí Maybe $ Œ£ (Fin n √ó Fin n) (uncurry ùîΩ._‚â§_) √ó Fin n
  pork ((a , b) , c)= ax ,‚Çò readMaybe c
    where
    ax = R >>= Œª (a' , b') ‚Üí map‚Çò (f a' b') $ decToMaybe $ a' ùîΩ.‚â§? b'
      where
      f = _,_ ‚àò‚ÇÇ _,_
      R = readMaybe a ,‚Çò readMaybe b

  orsygenturfa'i‚ÇÉ : {n : ‚Ñï}
                  ‚Üí String
                  ‚Üí (Maybe $ _√ó_
                      (Œ£ (Fin n √ó Fin n) (uncurry ùîΩ._‚â§_))
                      (Fin n))
  orsygenturfa'i‚ÇÉ = pork <=< orsispita

open Orsygenturfa'i‚ÇÉ
  using (
    orsygenturfa'i‚ÇÉ
  )
\end{code}

\subsection{le ctaipe be le su'u la'oi .\F{orsygenturfa'i‚ÇÉ}.\ mapti}

\begin{code}
module Orsygenturfa'i‚ÇÉVeritas where
  open Orsygenturfa'i‚ÇÉ

  lisporv : (a b c : String)
          ‚Üí (_‚â°_
              (lispork $ (a ‚à∑ []) ‚à∑ (b ‚à∑ c ‚à∑ []) ‚à∑ [])
              (just $ (a , b) , c))
  lisporv _ _ _ = refl

  lisporn : (x : List $ List String)
          ‚Üí (¬¨_
              (Œ£ (String √ó String √ó String)
              (Œª (a , b , c) ‚Üí
                (x ‚â° (a ‚à∑ []) ‚à∑ (b ‚à∑ c ‚à∑ []) ‚à∑ []))))
          ‚Üí lispork x ‚â° nothing
  lisporn = {!!}

  orspiv : (a b c : ‚Ñï)
         ‚Üí (x : Char)
         ‚Üí false ‚â° isDigit x
         ‚Üí let x' = ùïä.fromChar x in
           (_‚â°_
             (just $ (show a , show b) , show c)
             (orsispita
               (show a ++ "," ++ show b ++ x' ++ show c)))
  orspiv a b c x j = sym $ begin
    orsispita K ‚â°‚ü® refl ‚ü©
    L (ùïÉ.map (w aD?) $ w (_‚âü ',') $ K) ‚â°‚ü® {!!} ‚ü©
    L' (ùïÉ.map (w' aD?) $ w' (_‚âü ',') $ K') ‚â°‚ü® {!!} ‚ü©
    L' (ùïÉ.map (w' aD?) $ s' a ‚à∑ [ s'bxs'c ]) ‚â°‚ü® refl ‚ü©
    L' (w' aD? (s' a) ‚à∑ ùïÉ.map (w' aD?) [ s'bxs'c ]) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® uadysas a ‚ñπ cong (L' ‚àò (_‚à∑ ùïÉ.map (w' aD?) [ s'bxs'c ])) ‚ü©
    L' ([ s' a ] ‚à∑ ùïÉ.map (w' aD?) [ s'bxs'c ]) ‚â°‚ü® refl ‚ü©
    L' ([ s' a ] ‚à∑ [ w' aD? s'bxs'c ])  ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® sabus ‚ñπ cong (L' ‚àò _‚à∑_ ([ s' a ]) ‚àò [_]) ‚ü©
    L' ([ s' a ] ‚à∑ [ s' b ‚à∑ [ s' c ] ]) ‚â°‚ü® refl ‚ü©
    L' (map‚ÇÇ s' abj) ‚â°‚ü® refl ‚ü©
    L (map‚ÇÇ (ùïä.fromList ‚àò s') abj) ‚â°‚ü® map‚ÇÇ-cong fL‚àòtL _ ‚ñπ cong L ‚ü©
    L (map‚ÇÇ s abj) ‚â°‚ü® refl ‚ü©
    just ((show a , show b) , show c) ‚àé
    where
    L = lispork
    [_] = ùïÉ.[_]
    w = ùïä.wordsBy
    w' = ùïÉ.wordsBy
    aD? = T? ‚àò Data.Bool.not ‚àò isDigit
    K = show a ++ "," ++ show b ++ ùïä.fromChar x ++ show c
    s = show
    s' = ùïä.toList ‚àò show
    s'bxs'c = s' b ++ x ‚à∑ s' c
    fL‚àòtL : (x : String) ‚Üí ùïä.fromList (ùïä.toList x) ‚â° x
    fL‚àòtL = {!!}
    K' = s' a ++ ',' ‚à∑ s' b ++ x ‚à∑ s' c
    abj = [ a ] ‚à∑ [ b ‚à∑ [ c ] ]
    sabus : w' aD? s'bxs'c ‚â° s' b ‚à∑ [ s' c ]
    sabus = {!!}
    uadysas : (a : ‚Ñï) ‚Üí w' aD? (s' a) ‚â° [ s' a ]
    uadysas = {!!}
    map‚ÇÇ : ‚àÄ {a b} ‚Üí {A : Set a} ‚Üí {B : Set b}
         ‚Üí (A ‚Üí B) ‚Üí List $ List A ‚Üí List $ List B
    map‚ÇÇ = ùïÉ.map ‚àò ùïÉ.map
    L' : List $ List $ List $ Char
       ‚Üí Maybe $ (String √ó String) √ó String
    L' = L ‚àò ùïÉ.map (ùïÉ.map ùïä.fromList)
    open ‚â°-Reasoning
    map‚ÇÇ-cong = DLP.map-cong ‚àò DLP.map-cong

  porkcos : {n : ‚Ñï}
          ‚Üí (a b : Fin n)
          ‚Üí (d : a ùîΩ.‚â§ b)
          ‚Üí (c : Fin n)
          ‚Üí (_‚â°_
              (pork $ (show a , show b) , show c)
              (just $ ((a , b) , d) , c))
  porkcos a b d c = begin
    pork ((show a , show b) , show c) ‚â°‚ü® refl ‚ü©
    _,‚Çò_ ax (readMaybe $ show c) ‚â°‚ü® rimcos c ‚ñπ cong (_,‚Çò_ ax) ‚ü©
    _,‚Çò_ ax (just c) ‚â°‚ü® ax‚â°justabd ‚ñπ cong (flip _,‚Çò_ $ just c) ‚ü©
    _,‚Çò_ (just $ (a , b) , d) (just c) ‚â°‚ü® refl ‚ü©
    just (((a , b) , d) , c) ‚àé
    where
    ax : Maybe $ Œ£ (Fin _ √ó Fin _) $ uncurry ùîΩ._‚â§_
    ax = R >>= Œª (a' , b') ‚Üí map‚Çò (f a' b') $ decToMaybe $ a' ùîΩ.‚â§? b'
      where
      f = Œª a b x ‚Üí (a , b) , x
      R = readMaybe (show a) ,‚Çò readMaybe (show b)
    rimcos : {n : ‚Ñï} ‚Üí (x : Fin n) ‚Üí readMaybe (show x) ‚â° just x
    rimcos = {!!}
    open ‚â°-Reasoning
    ax‚â°justabd : ax ‚â° just ((a , b) , d)
    ax‚â°justabd = {!!}

  pav : {n : ‚Ñï}
      ‚Üí (v x z : Fin n)
      ‚Üí (d : v ùîΩ.‚â§ x)
      ‚Üí (c : Char)
      ‚Üí false ‚â° isDigit c
      ‚Üí (_‚â°_
          (just $ ((v , x) , d) , z)
          (orsygenturfa'i‚ÇÉ
            (let c' = ùïä.fromChar c in
             show v ++ "," ++ show x ++ c' ++ show z)))
  pav v x z d c j = sym $ begin
    orsygenturfa'i‚ÇÉ (k‚ÇÉ v x c z) ‚â°‚ü® refl ‚ü©
    orsispita (k‚ÇÉ v x c z) >>= pork ‚â°‚ü® refl ‚ü©
    orsispita (k‚ÇÉ (t v) (t x) c $ t z) >>= pork ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® orspiv (t v) (t x) (t z) c j ‚ñπ sym ‚ñπ cong (_>>= pork) ‚ü©
    just ((show (t v) , show (t x)) , show (t z)) >>= pork ‚â°‚ü® refl ‚ü©
    pork ((show (t v) , show (t x)) , show (t z)) ‚â°‚ü® refl ‚ü©
    pork ((show v , show x) , show z) ‚â°‚ü® porkcos v x d z ‚ü©
    just (((v , x) , d) , z) ‚àé
    where
    t = ùîΩ.to‚Ñï
    k‚ÇÉ : ‚àÄ {a b c} ‚Üí {A : Set a} ‚Üí {B : Set b} ‚Üí {C : Set c}
       ‚Üí ‚¶É Show A ‚¶Ñ ‚Üí ‚¶É Show B ‚¶Ñ ‚Üí ‚¶É Show C ‚¶Ñ
       ‚Üí A ‚Üí B ‚Üí Char ‚Üí C ‚Üí String
    k‚ÇÉ v x c z = show v ++ "," ++ show x ++ c' ++ show z
      where
      c' = ùïä.fromChar c
    open ‚â°-Reasoning
\end{code}

\section{la'oi .\F{reed}.}
ni'o ga jonai la'oi .\IC{nothing}.\ du ko'a goi la'o zoi.\ \F{reed} \B x \B s\ .zoi.\ gi ga je la'oi .\B s.\ midnoi fo la'o zoi.\ \Xr{ed}{1} .zoi.\ je cu mapti la'o zoi.\ \D{Cmd} \B x\ .zoi.\ gi ko'a me'oi .\IC{just}.\ lo mapti be la'oi .\B s.

\begin{code}
module Reed where
  module No where
    g : {x : Buffer} ‚Üí Char ‚Üí Maybe $ Cmd x
    g {x} 'w' = map‚Çò Rejgau $ Buffer.datnyveicme x
    g 'u' = map‚Çò Xruti $ ùïÉ.head $ ùïÉ.allFin _
    g 'q' = just Sisti
    g 'Q' = just Sisti!
    g _ = nothing

    k : {x : Buffer} ‚Üí List String ‚Üí Maybe $ Cmd x
    k ("w" ‚à∑ xs@(_ ‚à∑ _)) = just $ Rejgau $ ùïä.unwords xs
    k _ = nothing

    t : {x : Buffer} ‚Üí String ‚Üí Maybe $ Cmd x
    t = g <=< (ùïÉ.head ‚àò ùïä.toList)

  module Pa where
    g : {x : Buffer} ‚Üí Buffer.F x ‚Üí Char ‚Üí Maybe $ Cmd x
    g n 'a' = just $ Jmina n
    g n 'i' = just $ Jmini n
    g _ _ = nothing

    t : {x : Buffer} ‚Üí String ‚Üí Maybe $ Cmd x
    t {x} s = uncurry g =<<_ $ _,‚Çò_ n $ ùïÉ.last $ ùïä.toList s
      where
      n = pamoinamcu s >>= from‚Ñï?

  module Re where
    g : (x : Buffer)
      ‚Üí (a b : Buffer.F x)
      ‚Üí (a ùîΩ.‚â§ b)
      ‚Üí Char
      ‚Üí Maybe $ Cmd x
    g x a b z j with j
    ... | 'c' = just $ Basti a b z
    ... | 'd' = just $ Vimcu a b z
    ... | 'n' = just $ Namcusku a b z
    ... | 'p' = just $ Cusku a b z
    ... | _ = nothing

    t : (x : Buffer) ‚Üí String ‚Üí Maybe $ Cmd x
    t x s = _>>= g' $ (Data.Maybe.ap ‚àò‚ÇÇ map‚Çò) _,_ (romoi s) og
      where
      og = orsygenturfa'i $ romoivimcu s
      romoi = ùïÉ.last ‚àò ùïä.toList
      g' = Œª (r' , _ , z) ‚Üí g x _ _ z r'

  module Ci where
    g : {x : Buffer}
      ‚Üí (a b c : Buffer.F x)
      ‚Üí (a ùîΩ.‚â§ b)
      ‚Üí Char
      ‚Üí Maybe $ Cmd x
    g a b c d x with x
    ... | 'm' = just $ Muvgau a b c d
    ... | _ = nothing

    t : {x : Buffer} ‚Üí String ‚Üí Maybe $ Cmd x
    t {x} s = g' =<<_ $ c ,‚Çò orsygenturfa'i‚ÇÉ s
      where
      g' = Œª (z , (_ , d) , c) ‚Üí g _ _ c d z
      c = f $ ùïÉ.filter aintDigit? $ ùïä.toList s
        where
        aintDigit? = T? ‚àò Data.Bool.not ‚àò isDigit
        f : _ ‚Üí _
        f (x ‚à∑ []) = just x
        f _ = nothing

  reed : (x : Buffer) ‚Üí String ‚Üí Maybe $ Cmd x
  reed x s = ùïÉ.head $ ùïÉ.mapMaybe id terp
    where
    terp : List $ Maybe $ Cmd x
    terp = No.t s ‚à∑ Pa.t s ‚à∑ Re.t x s ‚à∑ No.k s' ‚à∑ []
      where
      s' = ùïä.wordsBy (_‚âü ' ') s

open Reed
  using (
    reed
  )
\end{code}

\subsection{le krinu be le me'oi .\AgdaKeyword{module}.\ co'e}
ni'o pilno ko'a goi le me'oi .\AgdaKeyword{module}.\ co'e ki'u le su'u tu'a ko'a filri'a lo nu ciksi lo ctaipe be le su'u mapti  .i la .varik.\ na jinvi le du'u sarcu fa lo nu ciksi lo steci be la'oi .\F{reed}.\ jenai zo'e bau la .lojban.

\subsection{le cmene be le me'oi .\AgdaKeyword{module}.\ fancu}
ni'o zo .k.\ cmavlaka'i zo konkatena

.i zo .t.\ cmavlaka'i zo tolsti

.i cumki fa lo nu su'o da zo'u zo .g.\ cmavlaka'i da

\subsection{le ctaipe be le su'u la'oi .\F{reed}.\ mapti}

\begin{code}
module ReedVeritas where
  private
    k‚ÇÅ : (x : Buffer)
       ‚Üí (a : Buffer.F x)
       ‚Üí Char
       ‚Üí String
    k‚ÇÅ _ a x = show (ùîΩ.to‚Ñï a) ++ ùïä.fromChar x

    k‚ÇÇ : (x : Buffer)
       ‚Üí (a b : Buffer.F x)
       ‚Üí Char
       ‚Üí String
    k‚ÇÇ _ a b x = f a ++ "," ++ f b ++ ùïä.fromChar x
      where
      f = show ‚àò ùîΩ.to‚Ñï

    k‚ÇÉ : (x : Buffer)
       ‚Üí (a b c : Buffer.F x)
       ‚Üí Char
       ‚Üí String
    k‚ÇÉ x a b c s = k‚ÇÇ x a b s ++ show (ùîΩ.to‚Ñï c)

  uin : (x : Buffer)
      ‚Üí reed x "w" ‚â° map‚Çò Rejgau (Buffer.datnyveicme x)
  uin x = begin
    reed x "w" ‚â°‚ü® refl ‚ü©
    ùïÉ.head (ùïÉ.mapMaybe id L) ‚â°‚ü® duridos ‚ü©
    ùïÉ.head (ùïä.toList "w") >>= Reed.No.g ‚â°‚ü® refl ‚ü©
    map‚Çò Rejgau (Buffer.datnyveicme x) ‚àé
    where
    open Reed
    ridos = ùïÉ.head (ùïä.toList "w") >>= Reed.No.g
    L = ridos ‚à∑ _
    duridos : ùïÉ.head (ùïÉ.mapMaybe id L) ‚â° ridos
    duridos with ridos
    ... | just _ = refl
    ... | nothing = refl
    open ‚â°-Reasoning

  -- ni'o la .varik. cu stidi lo nu tcidu le velcki be
  -- la .uin. fa lo na jimpe be fi la .kybin. je la'oi
  -- .kybin'.

  kybin : (x : Buffer)
        ‚Üí reed x "q" ‚â° just Sisti
  kybin _ with ùïÉ.head (ùïä.toList "q") >>= Reed.No.g
  ... | just _ = refl
  ... | nothing = refl

  kybin' : (x : Buffer)
         ‚Üí reed x "Q" ‚â° just Sisti!
  kybin' _ with ùïÉ.head (ùïä.toList "Q") >>= Reed.No.g
  ... | just _ = refl
  ... | nothing = refl

  xon : (x : Buffer)
      ‚Üí (z : ‚àÉ Œª n ‚Üí ‚Ñï.suc n ‚â° length (Buffer.citri x))
      ‚Üí reed x "u" ‚â° just (Xruti $ mink ùîΩ.zero $ proj‚ÇÇ z)
  xon x z = begin
    reed x "u" ‚â°‚ü® refl ‚ü©
    ùïÉ.head (ùïÉ.mapMaybe id terp') ‚â°‚ü® xedrenod 3 $ Reed.No.t "u" ‚ü©
    ùïÉ.head (ùïÉ.mapMaybe id $ Reed.No.t "u" ‚à∑ []) ‚â°‚ü® noxed _ ‚ñπ sym ‚ü©
    Reed.No.t "u" ‚â°‚ü® refl ‚ü©
    map‚Çò X (ùïÉ.head $ ùïÉ.allFin _) ‚â°‚ü® dzeroxe z ‚ñπ cong (map‚Çò X) ‚ü©
    just (X $ mink ùîΩ.zero $ proj‚ÇÇ z) ‚àé
    where
    X = Xruti
    terp' = Reed.No.t "u" ‚à∑ ùïÉ.replicate 3 nothing
    dzeroxe : {n : ‚Ñï}
            ‚Üí (z : ‚àÉ $ (_‚â° n) ‚àò ‚Ñï.suc)
            ‚Üí ùïÉ.head (ùïÉ.allFin n) ‚â° just (mink ùîΩ.zero $ proj‚ÇÇ z)
    dzeroxe (_ , refl) = refl
    noxed : ‚àÄ {a} ‚Üí {A : Set a}
          ‚Üí (x : Maybe A)
          ‚Üí x ‚â° ùïÉ.head (ùïÉ.mapMaybe id $ x ‚à∑ [])
    noxed nothing = refl
    noxed (just _) = refl
    xedrenod : ‚àÄ {a} ‚Üí {A : Set a}
             ‚Üí (n : ‚Ñï)
             ‚Üí (x : Maybe A)
             ‚Üí ((_‚â°_ on_ $ ùïÉ.head ‚àò ùïÉ.mapMaybe id ‚àò _‚à∑_ x)
                 (ùïÉ.replicate n nothing)
                 [])
    xedrenod _ (just _) = refl
    xedrenod 0 nothing = refl
    xedrenod (‚Ñï.suc n) nothing = xedrenod n nothing
    open ‚â°-Reasoning

  ac : (x : Buffer)
     ‚Üí (a : Buffer.F x)
     ‚Üí just (Jmina a) ‚â° reed x (k‚ÇÅ x a 'a')
  ac x a = sym $ begin
    reed x (k‚ÇÅ x a 'a') ‚â°‚ü® refl ‚ü©
    reed x K ‚â°‚ü® {!!} ‚ü©
    Reed.Pa.t K ‚â°‚ü® {!!} ‚ü©
    _,‚Çò_ (pamoinamcu K >>= from‚Ñï?) (sl "a") >>= g' ‚â°‚ü® {!!} ‚ü©
    _,‚Çò_ (rms a) (sl "a") >>= g' ‚â°‚ü® refl ‚ü©
    _,‚Çò_ (rms a) (just 'a') >>= g' ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® rimco a ‚ñπ cong (Œª x ‚Üí _,‚Çò_ x _ >>= g') ‚ü©
    _,‚Çò_ (just a) (just 'a') >>= g' ‚â°‚ü® refl ‚ü©
    just (a , 'a') >>= g' ‚â°‚ü® refl ‚ü©
    Reed.Pa.g a 'a' ‚â°‚ü® refl ‚ü©
    just (Jmina a) ‚àé
    where
    g' = uncurry Reed.Pa.g
    K = k‚ÇÅ x a 'a'
    rms : {n : ‚Ñï} ‚Üí Fin n ‚Üí Maybe $ Fin n
    rms = readMaybe ‚àò show
    sl = ùïÉ.last ‚àò ùïä.toList
    rimco : {n : ‚Ñï} ‚Üí (x : Fin n) ‚Üí rms x ‚â° just x
    rimco = {!!}
    open ‚â°-Reasoning

  ic : (x : Buffer)
     ‚Üí (a : Buffer.F x)
     ‚Üí just (Jmini a) ‚â° reed x (k‚ÇÅ x a 'i')
  ic = {!!}

  mixer : (x : Buffer)
        ‚Üí (a b c : Buffer.F x)
        ‚Üí (d : a ùîΩ.‚â§ b)
        ‚Üí just (Muvgau a b c d) ‚â° reed x (k‚ÇÇ x a b 'm')
  mixer x a b c d = {!!}

  vim : (x : Buffer)
      ‚Üí (a b : Buffer.F x)
      ‚Üí (d : a ùîΩ.‚â§ b)
      ‚Üí just (Vimcu a b d) ‚â° reed x (k‚ÇÇ x a b 'd')
  vim x a b d = sym $ begin
    reed x (k‚ÇÇ x a b 'd') ‚â°‚ü® {!!} ‚ü©
    Reed.Re.t x (k‚ÇÇ x a b 'd') ‚â°‚ü® {!!} ‚ü©
    Reed.Re.g x a b d 'd' ‚â°‚ü® refl ‚ü©
    just (Vimcu a b d) ‚àé
    where
    open ‚â°-Reasoning

  uip : ((s : String) ‚Üí s ‚â°_ $ ùïä.unwords $ ùïä.wordsBy (_‚âü ' ') s)
      ‚Üí (x : Buffer)
      ‚Üí (s : String)
      ‚Üí (c : Char)
      ‚Üí ¬¨ (c ‚â° ' ')
      ‚Üí let c‚à∑s = ùïä.fromChar c ++ s in
        Data.Maybe.Is-just $ ùïÉ.uncons $ ùïä.wordsBy (_‚âü ' ') c‚à∑s
      ‚Üí just (Rejgau c‚à∑s) ‚â° reed x ("w " ++ c‚à∑s)
  uip unwords‚àòf x s c n uj = sym $ begin
    reed x ("w " ++ c‚à∑s) ‚â°‚ü® w++s‚â°w++fs ‚ñπ cong (reed x) ‚ü©
    reed x (unwords $ "w" ‚à∑ f c‚à∑s) ‚â°‚ü® {!!} ‚ü©
    k (f $ unwords $ "w" ‚à∑ f c‚à∑s) ‚â°‚ü® f‚àòunwords _ ‚ñπ cong k ‚ü©
    k ("w" ‚à∑ f c‚à∑s) ‚â°‚ü® f[c‚à∑s]‚â°v‚ÇÅ‚à∑v‚ÇÇ ‚ñπ cong (k ‚àò _‚à∑_ "w") ‚ü©
    k ("w" ‚à∑ v‚ÇÅ ‚à∑ v‚ÇÇ) ‚â°‚ü® refl ‚ü©
    j‚àòR (unwords $ v‚ÇÅ ‚à∑ v‚ÇÇ) ‚â°‚ü® refl ‚ü©
    j‚àòR _ ‚â°‚ü® f[c‚à∑s]‚â°v‚ÇÅ‚à∑v‚ÇÇ ‚ñπ sym ‚ñπ cong (j‚àòR ‚àò unwords) ‚ü©
    j‚àòR (unwords $ f c‚à∑s) ‚â°‚ü® unwords‚àòf c‚à∑s ‚ñπ sym ‚ñπ cong j‚àòR ‚ü©
    j‚àòR c‚à∑s ‚àé
    where
    open Reed.No using (k)
    c‚à∑s = ùïä.fromChar c ++ s
    f = ùïä.wordsBy $ _‚âü ' '
    v = Data.Maybe.to-witness uj
    v‚ÇÅ = proj‚ÇÅ v
    v‚ÇÇ = proj‚ÇÇ v
    j‚àòR = just ‚àò Rejgau
    f[c‚à∑s]‚â°v‚ÇÅ‚à∑v‚ÇÇ : f c‚à∑s ‚â° v‚ÇÅ ‚à∑ v‚ÇÇ
    f[c‚à∑s]‚â°v‚ÇÅ‚à∑v‚ÇÇ = consunwords uj
      where
      consunwords : ‚àÄ {a} ‚Üí {A : Set a}
                  ‚Üí {xs : List A}
                  ‚Üí (j : Data.Maybe.Is-just $ ùïÉ.uncons xs)
                  ‚Üí let j' = Data.Maybe.to-witness j in
                    xs ‚â° proj‚ÇÅ j' ‚à∑ proj‚ÇÇ j'
      consunwords {xs = X@(x ‚à∑ xs)} j = sym $ begin
        proj‚ÇÅ j' ‚à∑ proj‚ÇÇ j' ‚â°‚ü® {!!} ‚ü©
        x ‚à∑ xs ‚â°‚ü® refl ‚ü©
        X ‚àé
        where
        j' = Data.Maybe.to-witness j
        open ‚â°-Reasoning
    unwords = ùïä.unwords
    open Reed
    open ‚â°-Reasoning
    f‚àòunwords : (x : List String) ‚Üí f (unwords x) ‚â° x
    f‚àòunwords = {!!}
    w++s‚â°w++fs : "w " ++ c‚à∑s ‚â° unwords ("w" ‚à∑ f c‚à∑s)
    w++s‚â°w++fs = {!!}
\end{code}

\section{la \F{kanji}}
ni'o la'o zoi.\ \F{kanji} \Sym\{\B x\Sym\} \B s\ .zoi.\ .orsi li re lo jalge be lo nu co'e la'oi .\B s.\ la'oi .\B x.\ kei zo'e poi ga jonai ke'a du la'oi .\IC{nothing}.\ gi ga jonai cadga fa lo nu cusku ke'a fo lo co'e co mu'oi glibau.\ standard output .glibau.\ gi\ldots ga je co'e gi la .varik.\ na birti lo du'u zabna ciksi fo ma kau bau la .lojban.  .i ku'i gu zabna ciksi bau la .lojban.\ gi ciksi le ctaipe be le su'u mapti

\begin{code}
kanji : {x : Buffer}
      ‚Üí Cmd x
      ‚Üí Œ£ Buffer $ Maybe ‚àò _‚äé_ String ‚àò Cmd·µ¢‚Çí
kanji {x} Sisti = x ,_ $ just $ inj‚ÇÇ Sisti·µ¢‚Çí
kanji {x} Sisti! = x ,_ $ just $ inj‚ÇÇ Sisti!·µ¢‚Çí
kanji {x} (Jmina a) = x ,_ $ just $ inj‚ÇÇ $ Tcidu·µ¢‚Çí "/dev/stdin" a
kanji {x} (Cusku a b _) = x ,_ $ just $ inj‚ÇÅ $ unlines $ i BL
  where
  BL = Buffer.lerpinste x
  i = (ùîΩ.to‚Ñï a) ‚Üì_ ‚àò (ùîΩ.to‚Ñï b ‚Ñï.+ 1) ‚Üë_
kanji {x} (Namcusku a b m) = x ,_ $ just $ inj‚ÇÅ $ viiet kot
  where
  kot = from-inj‚ÇÅ $ from-just $ proj‚ÇÇ $ kanji {x} $ Cusku a b m
  viiet = unlines ‚àò ùïÉ.map stringCat' ‚àò uin ‚àò lines
    where
    stringCat' = Œª (x , z) ‚Üí show x ++ "\t" ++ z
    uin : List String ‚Üí List $ ‚Ñï √ó String
    uin = ùïÉ.zip $ ùîΩ.to‚Ñï a ‚Üì_ $ ùïÉ.upTo $ ùîΩ.to‚Ñï b ‚Ñï.+ 1
kanji {x} (Muvgau a b c _) = x' , nothing
  where
  x' = record x {
    citri = Buffer.cninycitri x;
    cablerpinsle = mink (Buffer.cablerpinsle x) {!!};
    lerpinste = ùîΩ.to‚Ñï a ‚Üë BL ++ {!!} ++ {!!}
    }
    where
    BL = Buffer.lerpinste x
kanji {x} (Vimcu a b _) = x' , nothing
  where
  x' = record x {
    citri = Buffer.cninycitri x;
    cablerpinsle = {!!};
    lerpinste = ùîΩ.to‚Ñï a ‚Üë Lz ++ ‚Ñï.suc (ùîΩ.to‚Ñï b) ‚Üì Lz}
    where
    Lz = Buffer.lerpinste x
kanji {x} (Jmini a) = {!!}
kanji {x} (Rejgau d) = x ,_ $ just $ inj‚ÇÇ $ Rejgau·µ¢‚Çí xl d
  where
  xl = unlines $ Buffer.lerpinste x
kanji {x} (Basti a b d) = kanji {x'} $ Jmina a‚à∏1'
  where
  a‚à∏1' = {!!}
  x' = proj‚ÇÅ $ kanji {x} $ Vimcu a b d
  a‚à∏1'‚â°z : ùîΩ.to‚Ñï a‚à∏1' ‚â° ùîΩ.to‚Ñï a ‚Ñï.‚à∏ 1
  a‚à∏1'‚â°z = {!!}
kanji {x} (Xruti n) = {!!}
\end{code}

\subsection{le ctaipe be le su'u la \F{kanji}\ cu mapti}

\begin{code}
module KanjyVeritas where
  sistid : (x : Buffer)
         ‚Üí kanji {x} Sisti ‚â°_ $ x , just (inj‚ÇÇ Sisti·µ¢‚Çí)
  sistid x = refl

  sistik : (x : Buffer)
         ‚Üí kanji {x} Sisti! ‚â°_ $ x , just (inj‚ÇÇ Sisti!·µ¢‚Çí)
  sistik x = refl

  dub‚ÇÇ : (x : Buffer)
       ‚Üí (a b : Buffer.F x)
       ‚Üí (d : a ùîΩ.‚â§ b)
       ‚Üí let K = Œª f ‚Üí kanji $ f a b d in
         let i = _‚â°_ x ‚àò proj‚ÇÅ ‚àò K in
         i Cusku √ó i Namcusku
  dub‚ÇÇ _ _ _ _ = refl , refl

  jminac : (x : Buffer)
         ‚Üí (a : Buffer.F x)
         ‚Üí (_‚â°_
             (kanji {x} $ Jmina a)
             (x ,_ $ just $ inj‚ÇÇ $ Tcidu·µ¢‚Çí "/dev/stdin" a))
  jminac _ _ = refl

  nilzilcmiv : (x : Buffer)
             ‚Üí (a b : Buffer.F x)
             ‚Üí (d : a ùîΩ.‚â§ b)
             ‚Üí let BLT = length ‚àò Buffer.lerpinste in
               (_‚â°_
                 (BLT $ proj‚ÇÅ $ kanji {x} $ Vimcu a b d)
                 (BLT x ‚Ñï.‚à∏_ $ ‚Ñï.suc $ ùîΩ.to‚Ñï b ‚Ñï.‚à∏ ùîΩ.to‚Ñï a))
  nilzilcmiv x a b d = begin
    lb x‚ÇÇ ‚â°‚ü® refl ‚ü©
    length (ùîΩ.to‚Ñï a ‚Üë Lz ++ ‚Ñï.suc (ùîΩ.to‚Ñï b) ‚Üì Lz) ‚â°‚ü® refl ‚ü©
    length (a' ‚Üë Lz ++ b'+1 ‚Üì Lz) ‚â°‚ü® DLP.length-++ $ a' ‚Üë Lz ‚ü©
    length (a' ‚Üë Lz) ‚Ñï.+ length (b'+1 ‚Üì Lz) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® DLP.length-drop b'+1 Lz ‚ñπ cong (‚Ñï._+_ _) ‚ü©
    length (a' ‚Üë Lz) ‚Ñï.+ (length Lz ‚Ñï.‚à∏ b'+1) ‚â°‚ü® refl ‚ü©
    length (a' ‚Üë Lz) ‚Ñï.+ (lb x ‚Ñï.‚à∏ b'+1) ‚â°‚ü® {!!} ‚ü©
    a' ‚Ñï.+ (lb x ‚Ñï.‚à∏ b'+1) ‚â°‚ü® DNP.+-comm a' _ ‚ü©
    lb x ‚Ñï.‚à∏ b'+1 ‚Ñï.+ a' ‚â°‚ü® v‚à∏x+z‚â°v‚à∏[x‚à∏z] $ flex d ‚ü©
    lb x ‚Ñï.‚à∏ (b'+1 ‚Ñï.‚à∏ a') ‚â°‚ü® refl ‚ü©
    lb x ‚Ñï.‚à∏ (‚Ñï.suc b' ‚Ñï.‚à∏ a') ‚â°‚ü® {!!} ‚ü©
    lb x ‚Ñï.‚à∏ ‚Ñï.suc (b' ‚Ñï.‚à∏ a') ‚â°‚ü® refl ‚ü©
    lb x ‚Ñï.‚à∏ ‚Ñï.suc (ùîΩ.to‚Ñï b ‚Ñï.‚à∏ ùîΩ.to‚Ñï a) ‚àé
    where
    b' = ùîΩ.to‚Ñï b
    b'+1 = ‚Ñï.suc b'
    a' = ùîΩ.to‚Ñï a
    Lz = Buffer.lerpinste x
    x‚ÇÇ = proj‚ÇÅ $ kanji {x} $ Vimcu a b d
    lb = length ‚àò Buffer.lerpinste
    flex : {a : ‚Ñï}
         ‚Üí {m n : Fin a}
         ‚Üí n ùîΩ.‚â§ m
         ‚Üí ùîΩ.to‚Ñï n ‚Ñï.‚â§ ‚Ñï.suc (ùîΩ.to‚Ñï m)
    flex = {!!}
    open ‚â°-Reasoning
    v‚à∏x+z‚â°v‚à∏[x‚à∏z] : {v x z : ‚Ñï}
                 ‚Üí z ‚Ñï.‚â§ x
                 ‚Üí v ‚Ñï.‚à∏ x ‚Ñï.+ z ‚â° v ‚Ñï.‚à∏ (x ‚Ñï.‚à∏ z)
    v‚à∏x+z‚â°v‚à∏[x‚à∏z] {z = 0} ‚Ñï.z‚â§n = n+0‚â°n _
      where
      n+0‚â°n : (n : ‚Ñï) ‚Üí n ‚Ñï.+ 0 ‚â° n
      n+0‚â°n 0 = refl
      n+0‚â°n (‚Ñï.suc n) = n+0‚â°n n ‚ñπ cong ‚Ñï.suc
    v‚à∏x+z‚â°v‚à∏[x‚à∏z] {v} {x} {z = ‚Ñï.suc z} (‚Ñï.s‚â§s s) = begin
      v ‚Ñï.‚à∏ x ‚Ñï.+ ‚Ñï.suc z ‚â°‚ü® {!!} ‚ü©
      v ‚Ñï.‚à∏ ‚Ñï.suc (x ‚Ñï.+ z) ‚â°‚ü® {!!} ‚ü©
      v ‚Ñï.‚à∏ (x ‚Ñï.‚à∏ ‚Ñï.suc z) ‚àé

  takeduv : (x : Buffer)
          ‚Üí (a b : Buffer.F x)
          ‚Üí (d : a ùîΩ.‚â§ b)
          ‚Üí let x‚ÇÇ = proj‚ÇÅ $ kanji {x} $ Vimcu a b d in
            (_‚â°_ on ((ùîΩ.to‚Ñï a) ‚Üë_ ‚àò Buffer.lerpinste)) x x‚ÇÇ
  takeduv x a b d = sym $ begin
    BLT (proj‚ÇÅ $ kanji {x} $ Vimcu a b d) ‚â°‚ü® refl ‚ü©
    ùîΩ.to‚Ñï a ‚Üë (BLT x ++ BLD x) ‚â°‚ü® refl ‚ü©
    ùîΩ.to‚Ñï a ‚Üë ((ùîΩ.to‚Ñï a ‚Üë BL x) ++ BLD x) ‚â°‚ü® teikteik _ _ ‚ü©
    BLT x ‚àé
    where
    BL = Buffer.lerpinste
    BLT = (ùîΩ.to‚Ñï a) ‚Üë_ ‚àò BL
    BLD = ‚Ñï.suc (ùîΩ.to‚Ñï b) ‚Üì_ ‚àò BL
    open ‚â°-Reasoning
    teikteik : ‚àÄ {a} ‚Üí {A : Set a}
             ‚Üí (x : List A)
             ‚Üí {z : List A}
             ‚Üí (n : Fin $ length x)
             ‚Üí let n' = ùîΩ.to‚Ñï n in
               n' ‚Üë (n' ‚Üë x ++ z) ‚â° n' ‚Üë x
    teikteik (_ ‚à∑ _) ùîΩ.zero = refl
    teikteik (_ ‚à∑ _) (ùîΩ.suc _) = teikteik _ _ ‚ñπ cong (_ ‚à∑_)

  dropyduv : (x : Buffer)
           ‚Üí (a b : Buffer.F x)
           ‚Üí (d : a ùîΩ.‚â§ b)
           ‚Üí let x‚ÇÇ = proj‚ÇÅ $ kanji {x} $ Vimcu a b d in
             (_‚â°_
               (‚Ñï.suc (ùîΩ.to‚Ñï b) ‚Üì Buffer.lerpinste x)
               (ùîΩ.to‚Ñï a ‚Üì Buffer.lerpinste x‚ÇÇ))
  dropyduv x a b d = sym $ begin
    ùîΩ.to‚Ñï a ‚Üì BL x‚ÇÇ ‚â°‚ü® refl ‚ü©
    a' ‚Üì (a' ‚Üë BL x ++ b'++ ‚Üì BL x) ‚â°‚ü® teikteikdrop (BL x) _ a ‚ü©
    b'++ ‚Üì BL x ‚àé
    where
    a' = ùîΩ.to‚Ñï a
    b'++ = ‚Ñï.suc $ ùîΩ.to‚Ñï b
    BL = Buffer.lerpinste
    x‚ÇÇ = proj‚ÇÅ $ kanji {x} $ Vimcu a b d
    teikteikdrop : ‚àÄ {a} ‚Üí {A : Set a}
                 ‚Üí (x z : List A)
                 ‚Üí (n : Fin $ length x)
                 ‚Üí ùîΩ.to‚Ñï n ‚Üì (ùîΩ.to‚Ñï n ‚Üë x ++ z) ‚â° z
    teikteikdrop (_ ‚à∑ _) _ ùîΩ.zero = refl
    teikteikdrop (_ ‚à∑ xs) z (ùîΩ.suc n) = teikteikdrop xs z n
    open ‚â°-Reasoning

  pindices : (x : Buffer)
           ‚Üí (a b : Buffer.F x)
           ‚Üí (d : a ùîΩ.‚â§ b)
           ‚Üí let K = proj‚ÇÇ $ kanji {x} $ Cusku a b d in
             let L = lines $ from-inj‚ÇÅ $ from-just K in
             let Lx = Buffer.lerpinste x in
             (n : Fin $ length L)
           ‚Üí (Œ£
               (ùîΩ.to‚Ñï n ‚Ñï.+ ùîΩ.to‚Ñï a ‚Ñï.< length Lx)
               (Œª ‚Ñì ‚Üí L ! n ‚â° Lx ! ùîΩ.from‚Ñï< ‚Ñì))
  pindices x a b d n = {!!} , {!!}

  muvduzilcmi : (x : Buffer)
              ‚Üí (a b c : Buffer.F x)
              ‚Üí (d : a ùîΩ.‚â§ b)
              ‚Üí ((_‚â°_ on (length ‚àò Buffer.lerpinste))
                  x
                  (proj‚ÇÅ $ kanji {x} $ Muvgau a b c d))
  muvduzilcmi x a b c d = sym $ begin
    ùìÅ (proj‚ÇÅ K) ‚â°‚ü® {!!} ‚ü©
    length x'‚ÇÅ ‚Ñï.+ length x'‚ÇÇ ‚Ñï.+ length x'‚ÇÉ ‚â°‚ü® {!!} ‚ü©
    ùìÅ x ‚àé
    where
    K = kanji {x} $ Muvgau a b c d
    ùìÅ = length ‚àò Buffer.lerpinste
    x' = Buffer.lerpinste x
    x'‚ÇÅ = ùîΩ.to‚Ñï a ‚Üë x'
    x'‚ÇÇ = ‚Ñï.suc (ùîΩ.to‚Ñï b) ‚Üì x'
    x'‚ÇÉ = ùîΩ.to‚Ñï a ‚Üì_ $ ‚Ñï.suc (ùîΩ.to‚Ñï b) ‚Üë x'
    open ‚â°-Reasoning

  muvipas : (x : Buffer)
          ‚Üí (a b c : Buffer.F x)
          ‚Üí (d : a ùîΩ.‚â§ b)
          ‚Üí ((_‚â°_ on_ $ ùîΩ.to‚Ñï a ‚Üë_ ‚àò Buffer.lerpinste)
              x
              (proj‚ÇÅ $ kanji {x} $ Muvgau a b c d))
  muvipas x a b c d = sym $ begin
    T (BL x') ‚â°‚ü® DLP.take++drop (ùîΩ.to‚Ñï a) (BL x') ‚ñπ sym ‚ñπ cong T ‚ü©
    T (T (BL x') ++ D (BL x')) ‚â°‚ü® refl ‚ü©
    _ ‚â°‚ü® teikteik _ _ ‚ñπ cong (T ‚àò (_++ D (BL x'))) ‚ü©
    T (T (BL x) ++ D (BL x')) ‚â°‚ü® teikteik (BL x) a ‚ü©
    T (BL x) ‚àé
    where
    T = ùîΩ.to‚Ñï a ‚Üë_
    D = ùîΩ.to‚Ñï a ‚Üì_
    BL = Buffer.lerpinste
    x' = proj‚ÇÅ $ kanji {x} $ Muvgau a b c d
    open ‚â°-Reasoning
    teikteik : ‚àÄ {a} ‚Üí {A : Set a}
             ‚Üí (x : List A)
             ‚Üí {z : List A}
             ‚Üí (n : Fin $ length x)
             ‚Üí let n' = ùîΩ.to‚Ñï n in
               n' ‚Üë (n' ‚Üë x ++ z) ‚â° n' ‚Üë x
    teikteik (_ ‚à∑ _) ùîΩ.zero = refl
    teikteik (x ‚à∑ xs) (ùîΩ.suc n) = teikteik xs n ‚ñπ cong (x ‚à∑_)

  muvisez : (x : Buffer)
          ‚Üí (a b c : Buffer.F x)
          ‚Üí (d : a ùîΩ.‚â§ b)
          ‚Üí let n = ‚Ñï.suc (ùîΩ.to‚Ñï b ‚Ñï.‚à∏ ùîΩ.to‚Ñï a) in
            let x' = proj‚ÇÅ $ kanji {x} $ Muvgau a b c d in
            (_‚â°_
              (n ‚Üë_ $ ùîΩ.to‚Ñï a ‚Üì_ $ Buffer.lerpinste x)
              (n ‚Üë_ $ ùîΩ.to‚Ñï c ‚Üì_ $ Buffer.lerpinste x'))
  muvisez x a b c d = begin
    n ‚Üë (a' ‚Üì BLT x) ‚â°‚ü® {!!} ‚ü©
    n ‚Üë (c' ‚Üì BLT x') ‚àé
    where
    a' = ùîΩ.to‚Ñï a
    b' = ùîΩ.to‚Ñï b
    c' = ùîΩ.to‚Ñï c
    n = ‚Ñï.suc $ b' ‚Ñï.‚à∏ a'
    x' = proj‚ÇÅ $ kanji {x} $ Muvgau a b c d
    BLT = Buffer.lerpinste
    open ‚â°-Reasoning

  muviros : (x : Buffer)
          ‚Üí (a b c : Buffer.F x)
          ‚Üí (d : a ùîΩ.‚â§ b)
          ‚Üí let x‚ÇÇ = proj‚ÇÇ $ kanji {x} $ Muvgau a b c d in
            (_‚â°_
              ((ùîΩ.to‚Ñï b) ‚Üì Buffer.lerpinste x)
              {!!})
  muviros = {!!}

  muvivimcus : (x : Buffer)
             ‚Üí (a b c : Buffer.F x)
             ‚Üí (d : a ùîΩ.‚â§ b)
             ‚Üí let n = ‚Ñï.suc (ùîΩ.to‚Ñï b ‚Ñï.‚à∏ ùîΩ.to‚Ñï a) in
               let x' = proj‚ÇÅ $ kanji {x} $ Muvgau a b c d in
               let L = Buffer.lerpinste in
               (_‚â°_
                 (ùîΩ.to‚Ñï a ‚Üë L x ++ ‚Ñï.suc (ùîΩ.to‚Ñï b) ‚Üì L x)
                 (ùîΩ.to‚Ñï c ‚Üë L x' ++ n ‚Üì L x'))
  muvivimcus = {!!}

  muvdusin : (x : Buffer)
           ‚Üí (a b : Buffer.F x)
           ‚Üí let R = DFP.‚â§-reflexive refl in
             let K = kanji {x} $ Muvgau a a b R in
             Data.Maybe.Is-nothing (proj‚ÇÇ K)
           √ó let x' = proj‚ÇÅ K in
             let L = Buffer.lerpinste in
             let e = muvduzilcmi x a a b R in
             L x ! a ‚â° L x' ! mink a e
           √ó (_‚â°_ on ((ùîΩ.to‚Ñï a ‚Ñï.‚äì ùîΩ.to‚Ñï b) ‚Üë_ ‚àò L)) x x'
           √ó (_‚â°_ on ((ùîΩ.to‚Ñï a ‚Ñï.‚äî ùîΩ.to‚Ñï b) ‚Üë_ ‚àò L)) x x'
  muvdusin = {!!}

  xrutis : (x : Buffer)
         ‚Üí (n : Fin $ length $ Buffer.citri x)
         ‚Üí (_‚â°_
             (kanji {x} $ Xruti n)
             (let x' = Buffer.citri x ! n in
              (_,_
                record x {
                  lerpinste = proj‚ÇÅ x';
                  cablerpinsle = proj‚ÇÇ x';
                  citri = {!!}}
                nothing)))
  xrutis = {!!}
\end{code}

\chapter{le skami co'e}

\section{la'oi .\F{main}.}
ni'o zabna ciksi la'oi .\F{main}.\ fo ma bau la .lojban.

\begin{code}
{-# NON_TERMINATING #-}
main : Main
main = run $ IO.lift snurytcati IO.>> getArgs IO.>>= uic ‚àò ùïÉ.head
  where
  postulate snurytcati : ABIO.IO ABU.‚ä§
  {-# FOREIGN GHC import System.OpenBSD.Plegg #-}
  {-# COMPILE GHC snurytcati = plegg [RPath, WPath, Stdio] #-}
  uic : Maybe String ‚Üí IO ‚ä§
  uic = ‚ü≤ <=<·µ¢‚Çí maybe mkDef (IO.pure def)
    where
    _<=<·µ¢‚Çí_ : ‚àÄ {a}
            ‚Üí {A B C : Set a}
            ‚Üí (B ‚Üí IO C)
            ‚Üí (A ‚Üí IO B)
            ‚Üí A
            ‚Üí IO C
    _<=<·µ¢‚Çí_ g = _‚àò_ $ IO._>>= g
    def = record {
      datnyveicme = nothing;
      lerpinste = "" ‚à∑ List.[];
      cablerpinsle = ùîΩ.zero;
      citri = List.[];
      rejgaudatni = nothing
      }
    mkDef : _
    mkDef c = uit ‚àò ùïä.lines IO.<$> readFile c
      where
      uit : _ ‚Üí _
      uit [] = record def {datnyveicme = just c}
      uit x@(_ ‚à∑ _) = record {
        datnyveicme = just c;
        lerpinste = x;
        cablerpinsle = ùîΩ.opposite ùîΩ.zero;
        citri = List.[];
        rejgaudatni = just c
        }
    ‚ü≤ : Buffer ‚Üí IO ‚ä§
    ‚ü≤ x = IO.getLine IO.>>= f ‚àò reed x
      where
      f : Maybe $ Cmd x ‚Üí IO ‚ä§
      f nothing = IO.putStrLn "?" IO.>> ‚ü≤ x
      f (just c) with kanji c
      ... | x' , nothing = ‚ü≤ x'
      ... | x' , just (inj‚ÇÅ z) = IO.putStrLn z IO.>> ‚ü≤ x'
      ... | x' , just (inj‚ÇÇ z) with z
      ... | Sisti!·µ¢‚Çí = IO.pure _
      ... | Skami·µ¢‚Çí a = {!!}
      ... | Tcidu·µ¢‚Çí a b = {!!}
      ... | Rejgau·µ¢‚Çí a b = IO.writeFile b a IO.>> ‚ü≤ x
      ... | Sisti·µ¢‚Çí = f $ map‚Çò (Œª _ ‚Üí Sisti!) $ decToMaybe $ r ‚âü c‚ÇÅ
        where
        r = Buffer.rejgaudatni x'
        c‚ÇÅ = map‚Çò (unlines ‚àò proj‚ÇÅ) $ ùïÉ.head $ Buffer.citri x'
\end{code}
\end{document}
